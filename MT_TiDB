#!/bin/bash
#
# Copyright (c) 2024, 2099, M  All rights reserved.
# Author:  mfhd04@163.com  
# OS    : X86 
# TiDB : v6.5 later

# set -x  
# set -x  

# basic env
tiupcmd="/home/tidb/.tiup/bin/tiup"

# Connection information
# MYPATH="/usr/local/mysql-8.0.28-macos11-arm64/bin/mysql"
MYPATH="/bin/mysql"
MYUSER="root"
#MYPASS=$(echo -n 'cm9vdA=='| base64 --decode)
MYPASS=$(echo -n 'cjAwdEAxMzE0'| base64 --decode)
MYHOST="10.0.0.89"
# MYHOST="120.92.112.20"
MYPORT="4000"


# Define ANSI escape sequences for colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
RESET='\033[0m'  # Reset color to default



usage()
{
  echo "
  Usage: mt <command> [<arguments>]
  e.g. : mt test
  
    General
      [] is the default ;  <> is a must
                                          
    Commands list:                          

      - basic                                                                 Display the TiDB Cluster Basic information
      - user                                                                  Display useres information in the server       
      - var | par <variables>                                                 Show the values of TiDB system variables. Support like query
      - config | conf <variables>                                             Show the values of TiDB component configuration. Support like query
      - char_coll | character and collation                                   Show all available character sets and collations,Support like query
      - autoinc                                                               Display the auto-incrementing information of the table in the TiDB database
      - d    | database                                                       Show all databases in mysql server. Support like query
      - dt                                                                    Show all tables in the database. Support like query
      - source <exec.sql>                                                     Execute an SQL script file. Takes a file name as an argument
      - desc <database_name> <table_name>                                     Display columns information about the table
      - col  | column  <database_name> <table_name>                           Display columns information about the table
      - find_obj                                                              Find table or index information containing specific keywords
      - host_cpu                                                              Display the host CPU information
      - time_to_tso <tso>                                                     Convert the time to tso
      - tso_to_time <time>                                                    Convert the tso to time

                                                                                 
      - tab_nopk                                                              Display tables in TiDB database without primary keys
      - tab_idx_col_dup                                                       Display the index information with duplicate columns
      - tab_idx  | index <database_name> <table_name>                         Display table indexes information
      - tab_info <database_name> <table_name>                                 Display table information, including attributes、indexes、columns、and create statements     
      - tab_size                                                              Display the table or index size
      - db_size                                                               Display the spescial db or all db size
      - tab_region_dist <database_name> <table_name>                          Display the table and index region distribute
      - tab_region_leader <database_name> <table_name>                        Display the table and index region leader distribute
      - index_region_dist <database_name> <table_name>  <index_name>          Display the index region distribute

      - stats_unhealthy_missing                                               Display Table statistics is unhealthy and missing
      - stats_table | stats_table <database_name> <table_name>                Display the table statistics information detail
      - stats_analyze_table  | sat <database_name> <table_name>               Analyze the table statistics
      - stats_analyze_table2 | sat2 <database_name> <table_name>              Analyze the table statistics with 1 samplerate
      - stats_drop_table | sdt <database_name> <table_name>                   Drop the table statistics     
                                                                
      - top_tikv_cpu_sql                                                      Display the Top consume tikv cpu SQL
      - top_avg_tikv_cpu_sql                                                  Display the Top avg consume tikv cpu SQL
      - top_tikv_keys_sql                                                     Display the Top scan keys SQL
      - top_fre_sql                                                           Display the High frequency SQL
      - top_mem_sql                                                           Display the top memory consume SQL
      - top_time_noidx_sql                                                    Display Query which SQL statements are not indexed and have the highest overall time consumption
      - top_time_high_fre_sql                                                 Display A single SQL statement is fast but has too many executions, resulting in the most time-consuming SQL statement in total
      - top_slow_query_sql                                                    Display SQL with the highest number of occurrences in slow query
                                                                               
      - hot_read_write                                                        Display the Current Hot table through information_schema.tidb_hot_regions
      - hot_tikv_store                                                        Display the Current Hot tikv store through information_schema.tidb_hot_regions
      
      - sql_diag_analysis                                                     SQL diagnosis and output related information
      - sql_plan_change                                                       Display the SQL List which Plan change at during special time;
      - sql_slow_exec_hist                                                    Display the slow query SQL execute history changes
      - sql_full_scan                                                         Display the full table scan SQL
      - sql_slow_long                                                         Display the slow query SQL long query time
      - sql_exec_detail                                                       Obtain the execution status of the specified SQL digest in the statement summary
      - sql_search_text                                                       Find SQL statements containing specific text from a slow query and INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY
      - sql_search_digest                                                     Find SQL statements containing specific sql digest from a slow query and INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY
      - sql_binding                                                           List All sql binding information from mysql.bind_info
      - sql_binding_filter | sql_binding_filter[ or sbw] <key_word>           List All sql binding information from mysql.bind_info,filter with the original sql text key words
      - sql_binding_enable_stmt                                               Enable the binding by the SQL Statement
      - sql_binding_disable_stmt                                              Disable the binding by the SQL Statement
      - sql_binding_enable_digest    | above v7.1.x                           Enable the binding by the SQL Digest
      - sql_binding_disable_digest   | above v7.1.x                           Disable the binding by the SQL Digest
      - sql_text | text                                                       Display the SQL Text through the SQL digest

      - dbstatus                                                              Obtain the current status of the database, including active sessions, token limit configuration, transaction blocking, and top slow queries in the past 30 minutes
      - active_sess_simple                                                    Display the active sessions Parts
      - active_sess                                                           Display the active sessions Parts and Group by instance/user/client ip
      - connection_summary                                                    TiDB database current connection information, excluding background processes ,Display in columns
      - connection_xplan                                                      Obtain the execution plan of the SQL corresponding to the specified connection ID
      - connection_detail <connection_id>                                     Display the special connection details
      - lock                                                                  Display session locking information  
      - kill_conneciton_id |mt kci connection_id                              Kill the specified connection ID
      - kill_session_all_select                                               Script to generate kill all select session's sql statements and execution
      - kill_session                                                          Script to generate kill session's sql statements and execution
      - kill_session_sql_digest                                               Script to generate kill session's sql statements via digest and execution

      - gc_blocker                                                            Query GC for session block through CLUSTER-LOG
      - ddl_blocker                                                           Query DDL for session blocker
      - pd_leader_change                                                      Change the PD Leader to other PD Member
      - tikv_leader_evict                                                     Evict the region leader on the special tikv host or tikv instance
      - tikv_leader_evict_recovery                                            Recovery the region leader evict policy on the special tikv

      - drcheck | dr <cluster_name>                                           Display the DR Auto-Sync Configuration and Status
      

  NOTE 
  ================
    - Set environment variable DBUSER to change connect string which  is \"$MYPATH -u$MYUSER -h$MYHOST -P$MYPORT\"
    - Set environment variable tit_TMP to the default temp directory (default if /tmp when not set)
    - Common abbreviations, beginning with g(global), e(exactly), ms(master slave), ending with g(\G Display in columns)

"
}

##################################################################################

EXEC_NAME=`basename $0`
ORA_PROG=$0
ARGS=""
tit_TMP="/tmp"

if [ "$MYPATH" = "" ]; then
  echo "Please enter TiDB path"
fi

if [ "$MYUSER" = "" ]; then
  echo "Please enter TiDB user "
fi

if [ "$MYPASS" = "" ]; then
	echo "Please enter TiDB user password"
fi

if [ "$MYHOST" = "" ]; then
  echo "Please enter TiDB service host"
fi

if [ "$MYPORT" = "" ]; then
  echo "Please enter TiDB service port"
fi

if [ -n "$MYPATH" ] && [ -n "$MYUSER" ] && [ -n "$MYPASS" ] && [ -n "$MYHOST" ] && [ -n "$MYPORT" ]; then
  DBUSER="$MYPATH -u$MYUSER -p$MYPASS -h$MYHOST -P$MYPORT"
  #echo $DBUSER
fi

if [ "$TiDB_TMP" = "" ]; then
  TiDB_TMP="/tmp"
fi

##########################################
#very important init parameter
#filedate=`date +"%Y%m%d_%H%M%S"`
filedate=`date +"%Y%m%d"`
ECHO=""
DEFNODISP="--"
DEFDISP=""
#INST="1"
#DEBUG="#"

#########################################################################
while [ 1 ]; do
  case "$1" in
    "-u")
      ARGS="$ARGS $1 $2"
      DBUSER=$2
      shift
      ;;
      
    "-e")#echo sql
      ECHO=";"
      ;;
      
    "-a") #all
      DEFNODISP=""
      ;;
      
    "-s") #simple
      DEFDISP="--"
      ;;
      
   # "-d")
   #   DEBUG=""
   #   ;;
      
   # "-i")
   #   ARGS="$ARGS $1 $2"
   #   INST=$2
   #   shift
   #   ;;

    *)
      break
      ;;
  esac
  shift
done
#############################################################################################
#Display script help
if [ $# -lt 1 ]; then
  usage 
  exit 1
fi

#############################################################################################
if [ "$1" = "test" ]; then
    $DBUSER -e 2>/dev/null "select SYSDATE(),version();";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed! Please check the target tidb cluster status and MT Configuration!"
    fi
    $ECHO
exit 0
fi


#############################################################################################
##this is just a template,if you add new command ,just copy and replace with your own script:
#############################################################################################
if [ "$1" = "basic" ]; then
    $DBUSER -e 2>/dev/null "select SYSDATE(),version();";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO
    echo ''
    echo ''
    echo '========================================= Current Session Status =========================================' 
    $DBUSER -e 2>/dev/null "status;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

    echo ''
    echo ''
    echo '========================================= TiDB DDL Owner ========================================='
    $DBUSER -e 2>/dev/null "admin show ddl"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    echo -e "${GREEN}------- Resign the ddl owner command -------${RESET}"
    echo -e "${RED}curl -X POST http://{TiDBIP}:10080/ddl/owner/resign${RESET}"
    $ECHO


    echo ''
    echo ''
    echo '========================================= information_schema.cluster_info ========================================='
    $DBUSER -e 2>/dev/null "select * from information_schema.cluster_info order by 1;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

    echo ''
    echo ''
    echo '========================================= TiKV Store Status ========================================='
    $DBUSER -e 2>/dev/null "select store_id,address,STORE_STATE_NAME,
                                   JSON_UNQUOTE(JSON_EXTRACT(label, '$\[2\]\.value')) AS Dc,
                                   JSON_UNQUOTE(JSON_EXTRACT(label, '$\[0\]\.value')) AS Logic,
                                   JSON_UNQUOTE(JSON_EXTRACT(label, '$\[1\]\.value')) AS Host,
                                   LEADER_COUNT,region_count,version,capacity,available,uptime from information_schema.tikv_store_status order by 4,5,6;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

    echo ''
    echo ''
    echo '========================================= mysql.tidb ========================================='
    $DBUSER -e 2>/dev/null "select VARIABLE_NAME,VARIABLE_value from mysql.tidb;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

    echo ''
    echo ''
    echo '========================================= Placement Labels Information ========================================='
    $DBUSER -e 2>/dev/null "show placement labels;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

    $DBUSER -e 2>/dev/null "show placement;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO
             
exit 0
fi




#############################################################################################
if [ "$1" = "dbstatus" ]; then
    $DBUSER -e 2>/dev/null "select SYSDATE(),version();";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

    echo ''
    echo ''
    echo '============================================== Token info ============================================='
    $DBUSER -e 2>/dev/null "select distinct a.instance as 'Token-info:instance',
       concat(a.act_cnt,'/',b.value) as 'act/token-limit',
       concat(round(a.act_cnt/b.value,4)*100,'%') act_pct  
from (select sum(ACT_CNT) act_cnt,sum(SLP_CNT) SLP_CNT,sum(ACT_CNT)+sum(SLP_CNT) all_cnt,INSTANCE
      from(SELECT (CASE WHEN COMMAND<>'Sleep' THEN 1 END ) AS ACT_CNT,
                  (CASE WHEN COMMAND='Sleep' THEN 1 END ) AS  SLP_CNT,
                  INSTANCE 
            FROM INFORMATION_SCHEMA.CLUSTER_PROCESSLIST) c 
      group by INSTANCE) a, 
      (select concat(substring_index(c.INSTANCE,':',1) ,':',c.value) instance,d.value from information_schema.CLUSTER_CONFIG c,
      information_schema.CLUSTER_CONFIG d 
      where c.key='status.status-port'  and d.key='token-limit') b 
where a.INSTANCE=b.INSTANCE 
order by act_pct desc,a.instance;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO


    echo ''
    echo ''
    echo '============================================== Lock  info ==============================================' 
   $DBUSER -e 2>/dev/null "SELECT
              c.SESSION_ID AS blocker_sid,
      date_format(c.START_TIME,'%Y-%m-%d %H:%i:%s') as  start_time,
              b.SESSION_ID     as blocked_sid,
              b.user           AS user_name         ,
              b.CURRENT_SQL_DIGEST,
      substr( (replace( b.CURRENT_SQL_DIGEST_TEXT,CHAR(10),'')),1,60)  as DIGEST_TEXT
      FROM
              information_schema.DATA_LOCK_WAITS  a,
              information_schema.CLUSTER_TIDB_TRX b,
      information_schema.CLUSTER_TIDB_TRX c
      WHERE
              a.TRX_ID=b.ID and a.CURRENT_HOLDING_TRX_ID=c.id
      order by blocker_sid,start_time,blocked_sid;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

    echo ''
    echo ''
    echo '========================================= Last 10 DDL objects ========================================='
    $DBUSER -e 2>/dev/null "select db_name,table_name,start_time,end_time,substr(query,1,60) from information_schema.ddl_jobs order by CREATE_TIME  desc limit 10 ;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO


    echo ''
    echo ''
    echo '========================================== TOP 10 SQL_SLOWLOG Recent 30 Minutes =========================================='
    $DBUSER -e 2>/dev/null "SELECT DIGEST 
		 , date_format(min(time),'%Y%m%d %H%i%s') min_time
         ,count(*) execs
		 , sum(process_keys)           AS  s_pro_kyes       
         , round(sum(query_time)  ,2)  AS  s_qry_time		
         , round(sum(Process_time),2)  AS  s_pro_time
         , round(sum(Wait_time)   ,2)  AS  s_wa_time
         , round(sum(Commit_time) ,2)  AS  s_com_time
         , sum(Request_count) AS  s_req_cnt        
         , sum(Write_keys)    AS  s_w_keys
         , max(Cop_proc_max)  AS  mx_cop_proc
		  
		,min(   substr( (replace( replace(replace(query,'  ',' '),'   ',' '),CHAR(10),'')),1,60))  query        
 FROM
          information_schema.CLUSTER_SLOW_QUERY
 WHERE
              time       >= TIMESTAMP(sysdate() - interval 30 minute)
          AND Is_internal = false
 GROUP BY
                           digest
						   ORDER BY   s_qry_time,s_pro_kyes,execs
   DESC limit 10 ;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

exit 0
fi


#############################################################################################
if [ "$1" = "active_sess_simple" -o "$1" = "ass" ]; then

    echo ''
    echo ''
    echo '============================================== Active Session List ============================================='
    $DBUSER -e 2>/dev/null "select * from information_schema.cluster_processlist where command<>'Sleep' order by 1,3;"
    if [ "$?" -gt "0" ]; then
      echo "Execution Failed!"
    fi
    $ECHO

exit 0
fi




#############################################################################################
if [ "$1" = "active_sess" -o "$1" = "as" ]; then

    echo ''
    echo ''
    echo '============================================== Token info ============================================='
    $DBUSER -e 2>/dev/null "select distinct a.instance as 'Token-info:instance',
       concat(a.act_cnt,'/',b.value) as 'act/token-limit',
       concat(round(a.act_cnt/b.value,4)*100,'%') act_pct  
from (select sum(ACT_CNT) act_cnt,sum(SLP_CNT) SLP_CNT,sum(ACT_CNT)+sum(SLP_CNT) all_cnt,INSTANCE
      from(SELECT (CASE WHEN COMMAND<>'Sleep' THEN 1 END ) AS ACT_CNT,
                  (CASE WHEN COMMAND='Sleep' THEN 1 END ) AS  SLP_CNT,
                  INSTANCE 
            FROM INFORMATION_SCHEMA.CLUSTER_PROCESSLIST) c 
      group by INSTANCE) a, 
      (select concat(substring_index(c.INSTANCE,':',1) ,':',c.value) instance,d.value from information_schema.CLUSTER_CONFIG c,
      information_schema.CLUSTER_CONFIG d 
      where c.key='status.status-port'  and d.key='token-limit') b 
where a.INSTANCE=b.INSTANCE 
order by act_pct desc,a.instance;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

    echo ''
    echo ''
    echo '============================================== Active Session List ============================================='
    $DBUSER -e 2>/dev/null "select * from information_schema.cluster_processlist where command<>'Sleep' order by 1,3;"
    if [ "$?" -gt "0" ]; then
      echo "Execution Failed!"
    fi
    $ECHO


    echo ''
    echo ''
    echo '============================================== Active Session Group by Instance ============================================='
    $DBUSER -e 2>/dev/null "select instance,count(*) from information_schema.cluster_processlist where command<>'Sleep' group by instance;"
    if [ "$?" -gt "0" ]; then
      echo "Execution Failed!"
    fi
    $ECHO

    echo ''
    echo ''
    echo '============================================== Active Session Group by User ============================================='
    $DBUSER -e 2>/dev/null "select user,count(*) from information_schema.cluster_processlist where command<>'Sleep' group by user;"
    if [ "$?" -gt "0" ]; then
      echo "Execution Failed!"
    fi
    $ECHO


    echo ''
    echo ''
    echo '============================================== Active Session Group by Client Host ============================================='
    $DBUSER -e 2>/dev/null "select substring_index(host,':',1),count(*) from information_schema.cluster_processlist where command<>'Sleep' group by substring_index(host,':',1)  order by substring_index(host,':',1);"
    if [ "$?" -gt "0" ]; then
      echo "Execution Failed!"
    fi
    $ECHO


    echo ''
    echo ''
    echo '============================================== Active Session With Lock and Transaction ============================================='
    $DBUSER -e 2>/dev/null "SELECT distinct SUBSTR(a.INSTANCE,1,22) AS INSTANCE ,
		 a.ID SID , 
    (SELECT distinct c.SESSION_ID
    FROM INFORMATION_SCHEMA.CLUSTER_TIDB_TRX c,INFORMATION_SCHEMA.DATA_LOCK_WAITS b
    WHERE c.ID=b.CURRENT_HOLDING_TRX_ID) AS blocker_sid , a.DIGEST, a.USER USERNAME , a.TIME ELSTIME , a.STATE SQL_STATE , a.COMMAND , SUBSTR((REPLACE(a.info,CHAR(10),'')),1,60) SQL_TEXT
FROM INFORMATION_SCHEMA.CLUSTER_PROCESSLIST a
LEFT JOIN INFORMATION_SCHEMA.CLUSTER_TIDB_TRX c
	ON a.ID =c.SESSION_ID
LEFT JOIN INFORMATION_SCHEMA.DATA_LOCK_WAITS b
	ON b.TRX_ID =c.ID
WHERE a.COMMAND <>'Sleep'
ORDER BY  INSTANCE, DIGEST , TIME;"
    if [ "$?" -gt "0" ]; then
      echo "Execution Failed!"
    fi
    $ECHO

exit 0
fi


#############################################################################################
if [ "$1" = "help" -o "$1" = "h" ]; then
  if [ "$2" = "" ]; then
    $DBUSER -e 2>/dev/null "help;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO
  else
    $DBUSER -e 2>/dev/null "help $2;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO
  fi

exit 0
fi


#############################################################################################
if [ "$1" = "database" -o "$1" = "d" ]; then
  if [ "$2" = "" ]; then
   
    $DBUSER -e 2>/dev/null "show databases;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO
   else 

    $DBUSER -e 2>/dev/null "show databases like '%$2%';";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO
  fi

exit 0
fi

#############################################################################################
if [ "$1" = "dt" ]; then

   if [ "$2" = "" ]; then
     echo "TiDB dt [database] <table_name>"
     exit 1
   elif [ "$3" = "" ]; then
     $DBUSER -e 2>/dev/null "SHOW full TABLES from $2;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
     $ECHO
   else
     echo $3
     $DBUSER -e 2>/dev/null "SHOW full TABLES from $2 like '%$3%';";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
     $ECHO
   fi

exit 0
fi

#############################################################################################
if [ "$1" = "source" ]; then
  if [ "$2" = "" ]; then
     echo "Please put in the SQL execution script!"
     echo "E.G: tit source <exec.sql>"
   else 
    $DBUSER -e 2>/dev/null "source $2;";
    $ECHO
  fi

exit 0
fi


#############################################################################################
if [ "$1" = "autoinc" ]; then

    $DBUSER -e 2>/dev/null "SELECT
					a.TABLE_SCHEMA,
					a.TABLE_NAME,
					a.COLUMN_NAME,
					a.ORDINAL_POSITION,
					a.DATA_TYPE,
					a.CHARACTER_MAXIMUM_LENGTH,
					a.COLUMN_KEY,
					a.EXTRA,
					a.COLUMN_COMMENT 
			FROM
				(
				SELECT
					t.TABLE_SCHEMA,
					t.TABLE_NAME,
					c.COLUMN_NAME,
					c.ORDINAL_POSITION,
					c.DATA_TYPE,
					c.CHARACTER_MAXIMUM_LENGTH,
					c.COLUMN_KEY,
					c.EXTRA,
					c.COLUMN_COMMENT 
				FROM
					information_schema.TABLES t,
					information_schema.COLUMNS c 
				WHERE
					t.TABLE_NAME = c.TABLE_NAME 
					AND t.TABLE_TYPE LIKE '%TABLE%' 
					AND t.TABLE_SCHEMA = c.TABLE_SCHEMA 
					AND t.TABLE_SCHEMA NOT IN ( 'information_schema', 'performance_schema', 'TiDB', 'sys' ) 
					AND c.COLUMN_KEY = 'PRI' 
					AND c.EXTRA = 'auto_increment' 
				ORDER BY
					t.TABLE_NAME,
					c.ORDINAL_POSITION 
				) a 
			WHERE
				a.ORDINAL_POSITION = 1 
				AND a.DATA_TYPE NOT IN ( 'varchar', 'VARCHAR' );
    ";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

exit 0
fi

#############################################################################################
if [ "$1" = "lock" ]; then
    echo "------------------------------------- The Lock Chain Detail -------------------------------------"
        $DBUSER -e 2>/dev/null "SELECT distinct 
        c.SESSION_ID AS blocker_sid,
		date_format(c.START_TIME,'%Y-%m-%d %H:%i:%s') as  start_time,
        b.SESSION_ID     as blocked_sid,
        b.user           AS user_name         ,
        b.CURRENT_SQL_DIGEST,       
		substr( (replace( b.CURRENT_SQL_DIGEST_TEXT,CHAR(10),'')),1,60)  as DIGEST_TEXT
FROM
        information_schema.DATA_LOCK_WAITS  a,
        information_schema.CLUSTER_TIDB_TRX b,
		information_schema.CLUSTER_TIDB_TRX c		
WHERE
        a.TRX_ID=b.ID and a.CURRENT_HOLDING_TRX_ID=c.id
		order by blocker_sid,start_time,blocked_sid;
        ";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO
    echo ''
    echo ''
    echo "------------------------------------- The Waiting Sessions -------------------------------------"
    $DBUSER -e 2>/dev/null "select tl.key_count ,ts.instance,ts.id,ts.user,ts.host,ts.db,ts.command,
       ts.STATE ,tl.CURRENT_HOLDING_TRX_ID,ts.time,ts.DIGEST,ts.info
from  
    (select t.TRX_ID ,t.CURRENT_HOLDING_TRX_ID , count(1) as key_count 
     from information_schema.data_lock_waits t 
     group by t.TRX_ID ,t.CURRENT_HOLDING_TRX_ID) tl,
    information_schema.tidb_trx  tx ,
    information_schema.cluster_processlist ts
where tl.TRX_ID =tx.ID 
      and tx.SESSION_ID =ts.ID \G
	";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO
    echo ""
    echo ''
    echo ''
    echo "------------------------------------- The Blocker Sessions -------------------------------------"
    $DBUSER -e 2>/dev/null "select ts.instance,ts.id connection_id,tl.CURRENT_HOLDING_TRX_ID TRX_ID,ts.user,ts.host,ts.db,ts.command ,ts.STATE  ,ts.time,ts.DIGEST,ts.info
from  
    (select t.TRX_ID ,t.CURRENT_HOLDING_TRX_ID , count(1) as key_count 
     from information_schema.data_lock_waits t 
     group by t.TRX_ID ,t.CURRENT_HOLDING_TRX_ID) tl,
    information_schema.tidb_trx  tx ,
    information_schema.cluster_processlist ts
where tl.CURRENT_HOLDING_TRX_ID  =tx.ID 
      and tx.SESSION_ID =ts.ID \G
	";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO



exit 0
fi



#############################################################################################
if [ "$1" = "char_coll" -o "$1" = "cc" ]; then

   if [ "$2" = "" ]; then
     $DBUSER -e 2>/dev/null "SHOW CHARACTER SET;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
     $DBUSER -e 2>/dev/null "SHOW COLLATION;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
     $ECHO
   else
     $DBUSER -e 2>/dev/null "SHOW CHARACTER SET LIKE '%$2%';";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
     $DBUSER -e 2>/dev/null "SHOW COLLATION LIKE '%$2%';";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
     $ECHO
   fi

exit 0
fi


#############################################################################################
if [ "$1" = "col" -o "$1" = "column" ]; then
	 
	 if [ "$2" = "" -o "$3" = "" ]; then
     echo "Please enter database name and table name!"
     echo "E.G: mt col <database_name> <table_name>"
     
   else
     $DBUSER -e 2>/dev/null "SHOW COLUMNS FROM $3 FROM $2;";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
   fi

exit 0
fi


#############################################################################################
if [ "$1" = "tab_info" -o "$1" = "ti"  ]; then
   table_schema=`echo ${2,,}`
   table_name=`echo ${3,,}`

   if [ "$2" = "" -o "$3" = "" ]; then
     echo "Please enter database name and table name!"
     echo "E.G: MT_TiDB tab_info <database_name> <table_name>"

   else
     echo "================TABLE SIZE:"
     $DBUSER -e 2>/dev/null "select TABLE_SCHEMA,TABLE_NAME,TABLE_ROWS,(DATA_LENGTH+INDEX_LENGTH)/1024/1024 as table_size_mb from information_schema.tables where upper(TABLE_SCHEMA)='${2^^}' and upper(table_name)='${3^^}';";   
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     echo ""
     echo "================TABLE Stats:"
     $DBUSER -e 2>/dev/null "show stats_meta where upper(db_name)='${2^^}' and upper(table_name)='${3^^}'"
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
     $DBUSER -e 2>/dev/null "show stats_healthy where upper(db_name)='${2^^}' and upper(table_name)='${3^^}'"
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
     $DBUSER -e 2>/dev/null "show stats_histograms where upper(db_name)='${2^^}' and upper(table_name)='${3^^}'"
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
     echo ""
     echo "================TABLE ATTRIBUTES:"
     # $DBUSER -e 2>/dev/null "SHOW TABLE STATUS from $2 like '%$3%'\G;";
     $DBUSER -e 2>/dev/null "select * from information_schema.tables where lower(table_schema)='${table_schema}' and lower(table_name)='${table_name}' \G";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     echo ""
     echo "================TABLE INDEXES   :"
     $DBUSER -e 2>/dev/null "SHOW INDEX FROM $3 from $2;";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     echo ""
     echo "================TABLE COLUMNS   :"
     $DBUSER -e 2>/dev/null "DESC $2.$3;";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     echo ""
     echo "================TABLE CREATE DDL:"
     $DBUSER -e 2>/dev/null "SHOW CREATE TABLE $2.$3\G;";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     echo ""
     $ECHO

     echo "=========tab size from TIKV_REGION_STATUS ========="
     echo "Approximate_Size 表示压缩前表的单副本大小"
     echo "Disk_Size 表示压缩后表的大小"
     $DBUSER -e 2>/dev/null "SELECT  db_name , table_name , 
        INDEX_NAME,ROUND(SUM(total_size / cnt), 2) Approximate_Size_MB , 
				ROUND(SUM(total_size/cnt/( SELECT ROUND(AVG(value), 2) FROM METRICS_SCHEMA.store_size_amplification WHERE value > 0 ) ), 2) Disk_Size_MB
FROM   ( SELECT db_name , table_name ,INDEX_NAME, region_id , SUM(Approximate_Size) total_size , COUNT(*) cnt 
         FROM information_schema.TIKV_REGION_STATUS
         WHERE upper(db_name) =upper('"$2"')    
				       AND (upper(table_name) =upper('"$3"') 
							 OR upper(INDEX_NAME)=upper('"$3"')) 
         GROUP BY db_name , table_name ,INDEX_NAME, region_id ) tabinfo  
GROUP BY db_name , table_name,INDEX_NAME 
order by db_name,table_name,index_name;";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
  fi

exit 0
fi


#############################################################################################
if [ "$1" = "tab_size" -o "$1" = "ts" ]; then

read -p "Input tab/idx name :" segname
read -p "Input   dbname :" dbname

   if [ ! -n "$segname" ]; then
        echo "Plz input segname"
		exit 1
   fi

    if [ ! -n "$dbname" ]; then
        sqlcommand="SELECT  db_name , 
        table_name , 
		INDEX_NAME,
        ROUND(SUM(total_size / cnt), 2) Approximate_Size_MB , 
        ROUND(SUM(total_size/cnt/( SELECT ROUND(AVG(value), 2) FROM METRICS_SCHEMA.store_size_amplification WHERE value > 0 ) ), 2) Disk_Size_MB
FROM   ( SELECT db_name , table_name ,INDEX_NAME, region_id , SUM(Approximate_Size) total_size , COUNT(*) cnt
                FROM information_schema.TIKV_REGION_STATUS
                WHERE  upper(table_name) =upper('"${segname}"') OR upper(INDEX_NAME)=upper('"${segname}"')
                GROUP BY db_name , table_name ,INDEX_NAME, region_id ) tabinfo  
GROUP BY db_name , table_name,INDEX_NAME
order by db_name,table_name,index_name"
    else
        sqlcommand="SELECT  db_name , 
        table_name , 
		INDEX_NAME,
        ROUND(SUM(total_size / cnt), 2) Approximate_Size_MB , 
        ROUND(SUM(total_size/cnt/( SELECT ROUND(AVG(value), 2) FROM METRICS_SCHEMA.store_size_amplification WHERE value > 0 ) ), 2) Disk_Size_MB
FROM   ( SELECT db_name , table_name ,INDEX_NAME, region_id , SUM(Approximate_Size) total_size , COUNT(*) cnt
                FROM information_schema.TIKV_REGION_STATUS
                WHERE upper(db_name) =upper('"${dbname}"')    AND (upper(table_name) =upper('"${segname}"') OR upper(INDEX_NAME)=upper('"${segname}"')) 
                GROUP BY db_name , table_name ,INDEX_NAME, region_id ) tabinfo  
GROUP BY db_name , table_name,INDEX_NAME
order by db_name,table_name,index_name"
    fi

    if [ ! -n "$dbname" ]; then
        sqlcommand2="SELECT
CONCAT(table_schema,'.',table_name) AS 'Table_Name',
table_rows AS 'Number of Rows',
ROUND(data_length/(1024*1024),2) AS 'Data_Size_MB',
ROUND(index_length/(1024*1024),2) AS 'Index_Size_MB',
ROUND((data_length+index_length)/(1024*1024),2) AS 'Total_MB'
FROM
information_schema.TABLES
WHERE  upper(TABLE_NAME) =upper('"${segname}"')  order by 1;"
    else
       sqlcommand2="SELECT
CONCAT(table_schema,'.',table_name) AS 'Table_Name',
table_rows AS 'Number of Rows',
ROUND(data_length/(1024*1024),2) AS 'Data_Size_MB',
ROUND(index_length/(1024*1024),2) AS 'Index_Size_MB',
ROUND((data_length+index_length)/(1024*1024),2) AS 'Total_MB'
FROM
information_schema.TABLES
WHERE upper(table_schema)  = upper('"${dbname}"') and upper(TABLE_NAME) =upper('"${segname}"') 
order by 4;"
    fi


echo " • store_size_amplification 表示集群压缩比的平均值。"                                                  
echo "   除了使用 SELECT * FROM METRICS_SCHEMA.store_size_amplification; 语句进行查询以外，"                 
echo "   还可以查看 Grafana 监控 PD - statistics balance面板下各节点的 Size amplification 指标来获取该信息，"
echo "   集群压缩比的平均值即为所有节点的 Size amplification 平均值。"                                       
echo " • Approximate_Size 表示压缩前表的单副本大小，该值为估算值，并非准确值。"                              
echo " • Disk_Size 表示压缩后表的大小，可根据 Approximate_Size 和 store_size_amplification 得出估算值"      
echo ""
echo "   备注2: "                                                                                             
echo " • information_schema.tables.data_length 是通过统计信息（平均每行的大小）得到的估算值，统计信息中的行数 × 元组各列存储长度和。" 
echo " • information_schema.tables.TABLE_ROWS 是通过后台进程循环统计出来的"       
echo " • 该方法统计出来的size接近于dumpling文件导出的大小"
	
echo ''	
echo ======Segsize from TIKV_REGION_STATUS======
 
$DBUSER -e 2>/dev/null "$sqlcommand" -t
 
echo ''
echo ======Segsize from INFORMATION_SCHEMA.TABLES======
 
$DBUSER  -e 2>/dev/null "$sqlcommand2" -t

exit 0
fi


#############################################################################################
if [ "$1" = "db_size" -o "$1" = "ds" -o "$1" = "cs"  ]; then

read -p "Input   dbname(default ALL) :" dbname

    if [ ! -n "$dbname" ]; then
        sqlcommand="SELECT  db_name ,        
        ROUND(SUM(total_size / cnt), 2) Approximate_Size_MB , 
        ROUND(SUM(total_size/cnt/( SELECT ROUND(AVG(value), 2) FROM METRICS_SCHEMA.store_size_amplification WHERE value > 0 ) ), 2) Disk_Size_MB
FROM   ( SELECT db_name , table_name ,INDEX_NAME, region_id , SUM(Approximate_Size) total_size , COUNT(*) cnt
                FROM information_schema.TIKV_REGION_STATUS
                GROUP BY db_name , table_name ,INDEX_NAME, region_id ) tabinfo  
GROUP BY db_name 
order by 3 "
    else
        sqlcommand=" SELECT  db_name ,        
        ROUND(SUM(total_size / cnt), 2) Approximate_Size_MB , 
        ROUND(SUM(total_size/cnt/( SELECT ROUND(AVG(value), 2) FROM METRICS_SCHEMA.store_size_amplification WHERE value > 0 ) ), 2) Disk_Size_MB
FROM   ( SELECT db_name , table_name ,INDEX_NAME, region_id , SUM(Approximate_Size) total_size , COUNT(*) cnt
                FROM information_schema.TIKV_REGION_STATUS
				where upper(db_name)  = upper('"${dbname}"') 
                GROUP BY db_name , table_name ,INDEX_NAME, region_id ) tabinfo  
GROUP BY db_name order by 3  "
    fi

	
    if [ ! -n "$dbname" ]; then
        sqlcommand2="SELECT
table_schema  AS 'DB_Name',
ROUND(sum(data_length)/(1024*1024),2) AS 'Data_Size_MB',
ROUND(sum(index_length)/(1024*1024),2) AS 'Index_Size_MB',
ROUND(sum((data_length+index_length))/(1024*1024),2) AS 'Total_MB'
FROM
information_schema.TABLES  group by table_schema order by 4;"
    else
       sqlcommand2="SELECT
table_schema  AS 'DB_Name',
ROUND(sum(data_length)/(1024*1024),2) AS 'Data_Size_MB',
ROUND(sum(index_length)/(1024*1024),2) AS 'Index_Size_MB',
ROUND(sum((data_length+index_length))/(1024*1024),2) AS 'Total_MB'
FROM
information_schema.TABLES  WHERE upper(table_schema)  = upper('"${dbname}"')   group by table_schema order by 4;"
     fi	
	


echo " • store_size_amplification 表示集群压缩比的平均值。"                                                  
echo "   除了使用 SELECT * FROM METRICS_SCHEMA.store_size_amplification; 语句进行查询以外，"                 
echo "   还可以查看 Grafana 监控 PD - statistics balance面板下各节点的 Size amplification 指标来获取该信息，"
echo "   集群压缩比的平均值即为所有节点的 Size amplification 平均值。"                                       
echo " • Approximate_Size 表示压缩前表的单副本大小，该值为估算值，并非准确值。"                              
echo " • Disk_Size 表示压缩后表的大小，可根据 Approximate_Size 和 store_size_amplification 得出估算值"      
echo ""
echo "   备注2: "                                                                                             
echo " • information_schema.tables.data_length 是通过统计信息（平均每行的大小）得到的估算值，统计信息中的行数 × 元组各列存储长度和。" 
echo " • information_schema.tables.TABLE_ROWS 是通过后台进程循环统计出来的"       
echo " • 该方法统计出来的size接近于dumpling文件导出的大小"

	
	
echo ======== Segsize from TIKV_REGION_STATUS ========
 
$DBUSER -e 2>/dev/null "$sqlcommand" -t
 
echo ''
echo ======== Segsize from INFORMATION_SCHEMA.TABLES ========
 
$DBUSER  -e 2>/dev/null "$sqlcommand2" -t

exit 0
fi





#############################################################################################
if [ "$1" = "connection_summary" -o "$1" = "conn"  ]; then
    echo " *************************************** Connection by the instance ***************************************"
    $DBUSER -e 2>/dev/null "select instance,count(*) from information_schema.cluster_processlist group by  instance  order by instance;";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
    $ECHO
    echo ""
    echo ""
    echo "*************************************** Connection by the client ip ***************************************"
    $DBUSER -e 2>/dev/null "select substring_index(host,':',1),count(*) from information_schema.cluster_processlist group by  substring_index(host,':',1) order by substring_index(host,':',1);" 
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
    $ECHO
    echo ""
    echo ""
    echo "*************************************** Connection by the user ***************************************"
    $DBUSER -e 2>/dev/null "select user,count(*) from information_schema.cluster_processlist group by  user order by user" 
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
    $ECHO
    echo ""
    echo ""
    echo "*************************************** Connection by the Command State ***************************************"
    $DBUSER -e 2>/dev/null "select command,count(*) from information_schema.cluster_processlist group by  command order by 2" 
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
    $ECHO

exit 0
fi


#############################################################################################
if [ "$1" = "desc" ]; then

   if [ "$2" = "" -o "$3" = "" ]; then
     echo "Please enter database name and table name!"
     echo "E.G: mt desc <database_name> <table_name>"

   else
     $DBUSER -e 2>/dev/null "DESC $2.$3;";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
     
  fi

exit 0
fi


#############################################################################################
if [ "$1" = "tab_nopk" -o "$1" = "tn" ]; then

    $DBUSER -e 2>/dev/null "select table_schema,table_name,table_type,table_rows,tidb_pk_type,TIDB_ROW_ID_SHARDING_INFO 
from information_schema.tables 
where table_schema not in ('INFORMATION_SCHEMA','METRICS_SCHEMA','PERFORMANCE_SCHEMA','mysql','test','warehouses','tpcc') 
      and (table_schema,table_name) not in (select table_schema,table_name from information_schema.tidb_indexes where table_schema not in ('INFORMATION_SCHEMA','METRICS_SCHEMA','PERFORMANCE_SCHEMA','mysql','test','warehouses','tpcc') and key_name='PRIMARY')
order by table_name,table_schema;";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
    $ECHO

exit 0
fi


#############################################################################################
if [ "$1" = "tab_idx_col_dup" -o "$1" = "ticd" ]; then

    $DBUSER -e 2>/dev/null "select table_schema,table_name,idx_columns,count(key_name) dup_idx_cnt
from ( 
      select table_schema,table_name,key_name,group_concat(column_name order by seq_in_index) idx_columns
      from information_schema.tidb_indexes
      where table_schema not in ('INFORMATION_SCHEMA','METRICS_SCHEMA','PERFORMANCE_SCHEMA','mysql','test','warehouses','tpcc')
      group by table_schema,table_name,key_name
	  ) mx
group by table_schema,table_name,idx_columns
having count(idx_columns)>1
order by 1,2,3;"
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
    $ECHO

exit 0
fi

#############################################################################################
if [ "$1" = "ddl_blocker" -o "$1" = "db" ]; then

    $DBUSER -e 2>/dev/null "SELECT job_id AS job_id,
       JSON_EXTRACT(CAST(CAST(job_meta AS CHAR) AS JSON),_UTF8 '$.schema_name') AS db_name,
       JSON_EXTRACT(CAST(CAST(job_meta AS CHAR) AS JSON),_UTF8 '$.table_name') AS table_name,
       JSON_EXTRACT(CAST(CAST(job_meta AS CHAR) AS JSON),_UTF8 '$.query') AS query,
       session_id AS holder_session_id,
       txnstart AS txnstart,
       TIDB_DECODE_SQL_DIGESTS(all_sql_digests, 4096) AS SQL_DIGESTS
  FROM ((mysql.tidb_ddl_job) JOIN information_schema.cluster_tidb_trx)
  JOIN information_schema.cluster_processlist
 WHERE tidb_ddl_job.processing = 1
   AND FIND_IN_SET(JSON_EXTRACT(CAST(CAST(job_meta AS CHAR) AS JSON),_UTF8 '$.table_id'),cluster_tidb_trx.related_table_ids)
   AND cluster_tidb_trx.session_id = cluster_processlist.id;"
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
    $ECHO

exit 0
fi


#############################################################################################
if [ "$1" = "connection_detail" -o "$1" = "cd" ]; then
  if [ "$2" = "" ]; then
     echo "Please input the connection_id!"
     echo "E.G: mt connection_detail <connection_id>"

  else
    $DBUSER -e 2>/dev/null "select * from information_schema.cluster_processlist where id='$2' \G";
    if [ "$?" -gt "0" ]; then
      echo "Execution Failed!"
    fi
    $ECHO

  fi

exit 0
fi




#############################################################################################
if [ "$1" = "time_to_tso" -o "$1" = "ctime" ]; then
  if [ "$2" = "" ]; then
     echo "Please input the time!"
     echo "E.G: mt time_to_tso <time[e.g. 2023-03-28 12:00:00']>"

  else
    $DBUSER -e 2>/dev/null "select (unix_timestamp('$2')*1000) << 18";
    if [ "$?" -gt "0" ]; then
      echo "Execution Failed!"
    fi
    $ECHO

  fi

exit 0
fi


#############################################################################################
if [ "$1" = "tso_to_time" -o "$1" = "ctso" ]; then
  if [ "$2" = "" ]; then
     echo "Please input the tso!"
     echo "E.G: mt tso_to_time <tso>"

  else
    $DBUSER -e 2>/dev/null "select tidb_parse_tso($2);";
    if [ "$?" -gt "0" ]; then
      echo "Execution Failed!"
    fi
    $ECHO

  fi

exit 0
fi







#############################################################################################
if [ "$1" = "tab_idx" -o "$1" = "index" ]; then
  if [ "$2" = "" -o "$3" = "" ]; then
     echo "Please enter table name and database name!"
     echo "E.G: mt ind <database_name> <table_name>"
     
  else
    $DBUSER -e 2>/dev/null "SHOW INDEX FROM $3 from $2;";
    if [ "$?" -gt "0" ]; then
      echo "Execution Failed!"
    fi
    $ECHO
    
  fi

exit 0
fi

#############################################################################################
if [ "$1" = "tab_region_dist" -o "$1" = "trd" ]; then
	 
	 if [ "$2" = "" -o "$3" = "" ]; then
     echo "Please enter database name and table name!"
     echo "E.G: mt tab_region_dist <database_name> <table_name>"
     
   else
    echo "****************************  Table + Index Data Region Distribute ****************************"
     $DBUSER -e 2>/dev/null "SELECT distinct a.TIDB_TABLE_ID, b.DB_NAME, b.TABLE_NAME, b.REGION_ID, b.APPROXIMATE_SIZE
        , c.PEER_ID, c.STORE_ID, c.IS_LEADER, c.STATUS, d.ADDRESS
        , d.STORE_STATE_NAME, d.VERSION, d.CAPACITY, d.AVAILABLE, d.LABEL
FROM information_schema.TABLES a
        INNER JOIN information_schema.TIKV_REGION_STATUS b
        INNER JOIN information_schema.TIKV_REGION_PEERS c
        INNER JOIN information_schema.TIKV_STORE_STATUS d
WHERE a.TIDB_TABLE_ID = b.TABLE_ID
        AND b.REGION_ID = c.REGION_ID
        AND c.STORE_ID = d.STORE_ID
        AND a.TABLE_SCHEMA = '$2'
        AND a.TABLE_NAME = '$3';";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
     echo ''
     echo ''
     echo "****************************  Table Data Region Distribute ****************************"
     $DBUSER -e 2>/dev/null "   SELECT distinct a.TIDB_TABLE_ID, b.DB_NAME, b.TABLE_NAME, b.REGION_ID, b.APPROXIMATE_SIZE
           , c.PEER_ID, c.STORE_ID, c.IS_LEADER, c.STATUS, d.ADDRESS
           , d.STORE_STATE_NAME, d.VERSION, d.CAPACITY, d.AVAILABLE
   FROM information_schema.TABLES a
           INNER JOIN information_schema.TIKV_REGION_STATUS b
           INNER JOIN information_schema.TIKV_REGION_PEERS c
           INNER JOIN information_schema.TIKV_STORE_STATUS d
   WHERE a.TIDB_TABLE_ID = b.TABLE_ID
           AND b.REGION_ID = c.REGION_ID
           AND c.STORE_ID = d.STORE_ID
           AND b.is_index=0    -- 0 indicate table data，1 indicate index data
           AND a.TABLE_SCHEMA = '$2'
           AND a.TABLE_NAME = '$3'
   order by 1,2,3,4,5,6;";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO

     echo ''
     echo ''
     echo "****************************  Index Data Region Distribute ****************************"
     $DBUSER -e 2>/dev/null "   SELECT distinct a.TIDB_TABLE_ID, b.DB_NAME, b.TABLE_NAME, b.REGION_ID, b.APPROXIMATE_SIZE
           , c.PEER_ID, c.STORE_ID, c.IS_LEADER, c.STATUS, d.ADDRESS
           , d.STORE_STATE_NAME, d.VERSION, d.CAPACITY, d.AVAILABLE
   FROM information_schema.TABLES a
           INNER JOIN information_schema.TIKV_REGION_STATUS b
           INNER JOIN information_schema.TIKV_REGION_PEERS c
           INNER JOIN information_schema.TIKV_STORE_STATUS d
   WHERE a.TIDB_TABLE_ID = b.TABLE_ID
           AND b.REGION_ID = c.REGION_ID
           AND c.STORE_ID = d.STORE_ID
           AND b.is_index=1    -- 0 indicate table data，1 indicate index data
           AND a.TABLE_SCHEMA = '$2'
           AND a.TABLE_NAME = '$3'
   order by 1,2,3,4,5,6;";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
   fi


exit 0
fi

#############################################################################################
if [ "$1" = "tab_region_leader" -o "$1" = "trl" ]; then

   if [ "$2" = "" -o "$3" = "" ]; then
     echo "Please enter database name and table name!"
     echo "E.G: mt tab_region_leader <database_name> <table_name>"

   else
    echo "****************************  Table + Index Data Region Distribute ****************************"
     $DBUSER -e 2>/dev/null "SELECT p.store_id, count(DISTINCT p.peer_id) as region_number
        , count(CASE p.is_leader
                WHEN 1 THEN 1
        END) as region_leader
        , count(CASE
                WHEN s.is_index = 1
                        AND p.is_leader = 1
                THEN 1
        END) as region_index_leader
FROM information_schema.TIKV_REGION_STATUS s
        JOIN information_schema.TIKV_REGION_PEERS p ON s.region_id = p.region_id
WHERE s.db_name = '$2'
        AND s.table_name = '$3'
GROUP BY p.store_id
ORDER BY p.store_id;"
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
   fi


exit 0
fi






#############################################################################################
if [ "$1" = "index_region_dist" -o "$1" = "ird" ]; then
	 
	 if [ "$2" = "" -o "$3" = "" -o "$4" = "" ]; then
     echo "Please enter database name , table name and index_name!"
     echo "E.G: mt index_region_dist <database_name> <table_name> <index_name>"
     
   else
    echo "****************************  The table region distribute ****************************"
     $DBUSER -e 2>/dev/null "show table $2.$3 index $4 regions;";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO

     $DBUSER -e 2>/dev/null "SELECT distinct a.TIDB_TABLE_ID, b.DB_NAME, b.TABLE_NAME, b.REGION_ID, b.APPROXIMATE_SIZE
           , c.PEER_ID, c.STORE_ID, c.IS_LEADER, c.STATUS, d.ADDRESS
           , d.STORE_STATE_NAME, d.VERSION, d.CAPACITY, d.AVAILABLE
   FROM information_schema.TABLES a
           INNER JOIN information_schema.TIKV_REGION_STATUS b
           INNER JOIN information_schema.TIKV_REGION_PEERS c
           INNER JOIN information_schema.TIKV_STORE_STATUS d
   WHERE a.TIDB_TABLE_ID = b.TABLE_ID
           AND b.REGION_ID = c.REGION_ID
           AND c.STORE_ID = d.STORE_ID
           AND b.is_index=1    -- 0 indicate table data，1 indicate index data
           AND a.TABLE_SCHEMA = '$2'
           AND a.TABLE_NAME = '$3'
   order by 1,2,3,4,5,6;"
   if [ "$?" -gt "0" ]; then      echo "Execution Failed!"
      echo "Execution Failed!"
   fi
   fi

exit 0
fi

#############################################################################################
if [ "$1" = "host_cpu" -o "$1" = "hc"  ]; then
     $DBUSER -e 2>/dev/null "SELECT
	  b.time,
	  a.hostname,
	  a.ip,
	  a.types,
	  concat(round(b.cpu_used_percent,2),'%') host_cpu_used_percent
	FROM
	  (
	    SELECT
	      GROUP_CONCAT(TYPE) AS TYPES,
	      SUBSTRING_INDEX(instance, ':', 1) AS ip,
	      value AS hostname
	    FROM
	      information_schema.cluster_systeminfo
	    WHERE
	      name = 'kernel.hostname'
	    GROUP BY
	      ip,
	      hostname
	  ) a,
	  (
	    SELECT
	      time,
	      SUBSTRING_INDEX(instance, ':', 1) AS ip,
	(100 - value) AS cpu_used_percent
	    FROM
	      metrics_schema.node_cpu_usage
	    WHERE
	      MODE = 'idle'
	      AND time = NOW()
	  ) b
	WHERE
	  a.ip = b.ip order by 4,2,1;"
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO

exit 0
fi


#############################################################################################
if [ "$1" = "connection_xplan" -o "$1" = "cx" ]; then

read -p "Input the connection_id :" sid
 
   if [ ! -n "$sid" ]; then
        echo "Plz input sid"
		exit 1
   fi

# query sql
target_query="select  DIGEST,INFO from information_schema.cluster_processlist  where ID="${sid}" ;"

target_query2="explain for connection "${sid}""


echo ========== SQL INFO ==========
$DBUSER -e 2>/dev/null "$target_query" -t
 
echo ''
echo ========== SQL PLAN  ==========
$DBUSER  -e 2>/dev/null "$target_query2" -t


exit 0
fi



#############################################################################################
if [ "$1" = "stats_table" -o "$1" = "st" ]; then
   table_schema=`echo ${2,,}`
   table_name=`echo ${3,,}`

   if [ "$2" = "" -o "$3" = "" ]; then
     echo "Please enter database name and table name!"
     echo "E.G: MT_TiDB stats_table <database_name> <table_name>"

   else
     $DBUSER -e 2>/dev/null "show stats_meta where upper(db_name)='${2^^}' and upper(table_name)='${3^^}'"   
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
     $DBUSER -e 2>/dev/null "show stats_healthy where upper(db_name)='${2^^}' and upper(table_name)='${3^^}'"   
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
     $DBUSER -e 2>/dev/null "show stats_histograms where upper(db_name)='${2^^}' and upper(table_name)='${3^^}'"   
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
  fi

exit 0
fi


#############################################################################################
if [ "$1" = "stats_analyze_table" -o "$1" = "sat" ]; then
   table_schema=`echo ${2,,}`
   table_name=`echo ${3,,}`

   if [ "$2" = "" -o "$3" = "" ]; then
     echo "Please enter database name and table name!"
     echo "E.G: MT_TiDB stats_analyze_table <database_name> <table_name>"

   else
     echo "Begin Analyze the table stats........"
     $DBUSER -e 2>/dev/null "analyze table $2.$3;"
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
     echo "Complete the table stats analzye........"
  fi

exit 0
fi


#############################################################################################
if [ "$1" = "stats_analyze_table2" -o "$1" = "sat2" ]; then
   table_schema=`echo ${2,,}`
   table_name=`echo ${3,,}`

   if [ "$2" = "" -o "$3" = "" ]; then
     echo "Please enter database name and table name!"
     echo "E.G: MT_TiDB stats_analyze_table2 <database_name> <table_name>"

   else
     echo "Begin Analyze the table stats with 1 samplerate ........"
     $DBUSER -e 2>/dev/null "analyze table $2.$3 with 1 samplerate;"
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
     echo "Complete the table stats analzye........"
  fi

exit 0
fi


#############################################################################################
if [ "$1" = "stats_drop_table" -o "$1" = "sdt" ]; then
   table_schema=`echo ${2,,}`
   table_name=`echo ${3,,}`

   if [ "$2" = "" -o "$3" = "" ]; then
     echo "Please enter database name and table name!"
     echo "E.G: MT_TiDB stats_drop_table <database_name> <table_name>"

   else
     echo "Begin Drop the table stats ........"
     $DBUSER -e 2>/dev/null "drop stats $2.$3;"
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
     echo "Complete drop table stats ........"
  fi

exit 0
fi




#############################################################################################
if [ "$1" = "top_tikv_cpu_sql" -o "$1" = "ttcs" ]; then
start_time=""
end_time=""
# 提示用户输入开始时间，默认为半小时前
read -p "请输入开始时间（留空则默认为半小时前:$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")）: " start_time_input
# 如果用户未输入，则默认为半小时前
if [ -z "$start_time_input" ]; then
    start_time=$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    start_time=$(date -d "$start_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "开始时间：$start_time"

# 提示用户输入结束时间，默认为当前时间
read -p "请输入结束时间（留空则默认为当前时间:$(date "+%Y-%m-%d %H:%M:%S")）: " end_time_input
# 如果用户未输入，则默认为当前时间
if [ -z "$end_time_input" ]; then
    end_time=$(date "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    end_time=$(date -d "$end_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "结束时间：$end_time"
    echo "****************************** Check through the STATEMENTS_SUMMARY ******************************"
    $DBUSER -e 2>/dev/null "select schema_name,digest,digest_text,exec_count,
       round(min_latency/1000000,2)         tidb_min_latency_ms,
       round(avg_latency/1000000,2)         tidb_avg_latency_ms,
       round(max_latency/1000000,2)         tidb_max_latency_ms,
       round(avg_kv_time/1000000,2)         tidb_avg_kv_time_ms,
       round(avg_pd_time/1000000,2)         tidb_avg_pd_time_ms,   
       avg_mem/1024/1024                    tidb_avg_mem_mb,
       max_mem/1024/1024                    tidb_max_mem_mb, 
       avg_disk/1024/1024                   tidb_avg_disk_mb, 
       max_disk/1024/1024                   tidb_max_disk_mb,                       
       sum_cop_task_num                     tikv_cop_request_cnt,
       avg_processed_keys                   tikv_cop_avg_processed_keys,
       max_processed_keys                   tikv_cop_max_processed_keys,    
       avg_total_keys                       tikv_cop_avg_total_keys,
       max_total_keys                       tikv_cop_max_total_keys,     
       round(avg_process_time/1000000,2)    tikv_avg_process_time_ms,
       round(max_process_time/1000000,2)    tikv_max_process_time_ms,    
       round(avg_wait_time/1000000,2)       tikv_avg_sql_wait_time_ms,
       round(max_wait_time/1000000,2)       tikv_max_sql_wait_time_ms
from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY 
where SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
      and schema_name is not null 
      and stmt_type in ('Select','Update','Delete','Insert')
union
select schema_name,digest,digest_text,exec_count,
       round(min_latency/1000000,2)      tidb_min_latency_ms,
       round(avg_latency/1000000,2)      tidb_avg_latency_ms,
       round(max_latency/1000000,2)      tidb_max_latency_ms,
       round(avg_kv_time/1000000,2)      tidb_avg_kv_time_ms,
       round(avg_pd_time/1000000,2)      tidb_avg_pd_time_ms,
       avg_mem/1024/1024                 tidb_avg_mem_mb,
       max_mem/1024/1024                 tidb_max_mem_mb, 
       avg_disk/1024/1024                tidb_avg_disk_mb, 
       max_disk/1024/1024                tidb_max_disk_mb,            
       sum_cop_task_num                  tikv_cop_request_cnt,
       avg_processed_keys                tikv_cop_avg_processed_keys,
       max_processed_keys                tikv_cop_max_processed_keys,    
       avg_total_keys                    tikv_cop_avg_total_keys,
       max_total_keys                    tikv_cop_max_total_keys,     
       round(avg_process_time/1000000,2) tikv_avg_process_time_ms,
    round(max_process_time/1000000,2) tikv_max_process_time_ms,    
    round(avg_wait_time/1000000,2)    tikv_avg_sql_wait_time_ms,
       round(max_wait_time/1000000,2)    tikv_max_sql_wait_time_ms
from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY_HISTORY 
where SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
      and schema_name is not null 
      and stmt_type in ('Select','Update','Delete','Insert')
order by tikv_cop_request_cnt desc
limit 5 \G"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

    echo "****************************** Check through the CLUSTER_SLOW_QUERY ******************************"
    $DBUSER -e 2>/dev/null "SELECT digest,query,sum(Request_count), 
sum(Request_count)/count(digest) avg_rq,
count(digest)
FROM INFORMATION_SCHEMA.CLUSTER_SLOW_QUERY
WHERE Time > '${start_time}' AND time < '${end_time}'
GROUP BY digest,query
ORDER BY sum(Request_count) DESC 
limit 5 \G"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO


exit 0
fi


#############################################################################################
if [ "$1" = "top_avg_tikv_cpu_sql" -o "$1" = "tatcs" ]; then
start_time=""
end_time=""
# 提示用户输入开始时间，默认为半小时前
read -p "请输入开始时间（留空则默认为半小时前:$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")）: " start_time_input
# 如果用户未输入，则默认为半小时前
if [ -z "$start_time_input" ]; then
    start_time=$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    start_time=$(date -d "$start_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "开始时间：$start_time"

# 提示用户输入结束时间，默认为当前时间
read -p "请输入结束时间（留空则默认为当前时间:$(date "+%Y-%m-%d %H:%M:%S")）: " end_time_input
# 如果用户未输入，则默认为当前时间
if [ -z "$end_time_input" ]; then
    end_time=$(date "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    end_time=$(date -d "$end_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "结束时间：$end_time"
    echo "****************************** Check through the STATEMENTS_SUMMARY ******************************"
    $DBUSER -e 2>/dev/null "select schema_name,digest,digest_text,exec_count,
       round(min_latency/1000000,2)         tidb_min_latency_ms,
       round(avg_latency/1000000,2)         tidb_avg_latency_ms,
       round(max_latency/1000000,2)         tidb_max_latency_ms,
       round(avg_kv_time/1000000,2)         tidb_avg_kv_time_ms,
       round(avg_pd_time/1000000,2)         tidb_avg_pd_time_ms,   
       avg_mem/1024/1024                    tidb_avg_mem_mb,
       max_mem/1024/1024                    tidb_max_mem_mb, 
       avg_disk/1024/1024                   tidb_avg_disk_mb, 
       max_disk/1024/1024                   tidb_max_disk_mb,                       
       sum_cop_task_num                     tikv_cop_request_cnt,
       avg_processed_keys                   tikv_cop_avg_processed_keys,
       max_processed_keys                   tikv_cop_max_processed_keys,    
       avg_total_keys                       tikv_cop_avg_total_keys,
       max_total_keys                       tikv_cop_max_total_keys,     
       round(avg_process_time/1000000,2)    tikv_avg_process_time_ms,
       round(max_process_time/1000000,2)    tikv_max_process_time_ms,    
       round(avg_wait_time/1000000,2)       tikv_avg_sql_wait_time_ms,
       round(max_wait_time/1000000,2)       tikv_max_sql_wait_time_ms
from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY 
where SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
      and schema_name is not null 
      and stmt_type in ('Select','Update','Delete','Insert')
union
select schema_name,digest,digest_text,exec_count,
       round(min_latency/1000000,2)      tidb_min_latency_ms,
       round(avg_latency/1000000,2)      tidb_avg_latency_ms,
       round(max_latency/1000000,2)      tidb_max_latency_ms,
       round(avg_kv_time/1000000,2)      tidb_avg_kv_time_ms,
       round(avg_pd_time/1000000,2)      tidb_avg_pd_time_ms,
       avg_mem/1024/1024                 tidb_avg_mem_mb,
       max_mem/1024/1024                 tidb_max_mem_mb, 
       avg_disk/1024/1024                tidb_avg_disk_mb, 
       max_disk/1024/1024                tidb_max_disk_mb,            
       sum_cop_task_num                  tikv_cop_request_cnt,
       avg_processed_keys                tikv_cop_avg_processed_keys,
       max_processed_keys                tikv_cop_max_processed_keys,    
       avg_total_keys                    tikv_cop_avg_total_keys,
       max_total_keys                    tikv_cop_max_total_keys,     
       round(avg_process_time/1000000,2) tikv_avg_process_time_ms,
    round(max_process_time/1000000,2) tikv_max_process_time_ms,    
    round(avg_wait_time/1000000,2)    tikv_avg_sql_wait_time_ms,
       round(max_wait_time/1000000,2)    tikv_max_sql_wait_time_ms
from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY_HISTORY 
where SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
      and schema_name is not null 
      and stmt_type in ('Select','Update','Delete','Insert')
order by tikv_cop_avg_processed_keys desc
limit 5 \G"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO


    echo "****************************** Check through the CLUSTER_SLOW_QUERY ******************************"
    $DBUSER -e 2>/dev/null "select  db,digest,
        round(sum(query_time)*1000/count(*),2)     avg_query_time_ms,
        round(sum(Parse_time)*1000/count(*),2)     avg_Parse_time_ms,   
        round(sum(Compile_time)*1000/count(*),2)   avg_Compile_time_ms,
        round(sum(Optimize_time)*1000/count(*),2)  avg_Optimize_time_ms,
        round(sum(Prewrite_time)*1000/count(*),2)  avg_Prewrite_time_ms,
        round(sum(cop_time)*1000/count(*),2)       avg_cop_time_ms,
        round(sum(process_time)*1000/count(*),2)   avg_process_time_ms,
        round(sum(Total_keys)/count(*),2)          avg_Total_keys,
        round(sum(process_keys)/count(*),2)        avg_process_keys,
        round(sum(mem_max)/count(*),2)             avg_mem_max,
        round(sum(disk_max)/count(*),2)            avg_disk_max,
        query
from INFORMATION_SCHEMA.CLUSTER_SLOW_QUERY 
where is_internal=0 
      and time between '${start_time}' and '${end_time}'
group by db,digest,query
order by process_keys desc
limit 5 \G"
      if [ "$?" -gt "0" ]; then
         echo "Execution Failed!"
      fi
      $ECHO


exit 0
fi


#############################################################################################
if [ "$1" = "top_tikv_keys_sql" -o "$1" = "ttks" ]; then
start_time=""
end_time=""
# 提示用户输入开始时间，默认为半小时前
read -p "请输入开始时间（留空则默认为半小时前:$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")）: " start_time_input
# 如果用户未输入，则默认为半小时前
if [ -z "$start_time_input" ]; then
    start_time=$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    start_time=$(date -d "$start_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "开始时间：$start_time"

# 提示用户输入结束时间，默认为当前时间
read -p "请输入结束时间（留空则默认为当前时间:$(date "+%Y-%m-%d %H:%M:%S")）: " end_time_input
# 如果用户未输入，则默认为当前时间
if [ -z "$end_time_input" ]; then
    end_time=$(date "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    end_time=$(date -d "$end_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "结束时间：$end_time"
    echo "****************************** Check through the STATEMENTS_SUMMARY ******************************"
    $DBUSER -e 2>/dev/null "select schema_name,digest,digest_text,exec_count,
       round(min_latency/1000000,2)         tidb_min_latency_ms,
       round(avg_latency/1000000,2)         tidb_avg_latency_ms,
       round(max_latency/1000000,2)         tidb_max_latency_ms,
       round(avg_kv_time/1000000,2)         tidb_avg_kv_time_ms,
       round(avg_pd_time/1000000,2)         tidb_avg_pd_time_ms,   
       avg_mem/1024/1024                    tidb_avg_mem_mb,
       max_mem/1024/1024                    tidb_max_mem_mb, 
       avg_disk/1024/1024                   tidb_avg_disk_mb, 
       max_disk/1024/1024                   tidb_max_disk_mb,                       
       sum_cop_task_num                     tikv_cop_request_cnt,
       avg_processed_keys                   tikv_cop_avg_processed_keys,
       max_processed_keys                   tikv_cop_max_processed_keys,    
       avg_total_keys                       tikv_cop_avg_total_keys,
       max_total_keys                       tikv_cop_max_total_keys,     
       round(avg_process_time/1000000,2)    tikv_avg_process_time_ms,
       round(max_process_time/1000000,2)    tikv_max_process_time_ms,    
       round(avg_wait_time/1000000,2)       tikv_avg_sql_wait_time_ms,
       round(max_wait_time/1000000,2)       tikv_max_sql_wait_time_ms
from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY 
where SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
      and schema_name is not null 
      and stmt_type in ('Select','Update','Delete','Insert')
union
select schema_name,digest,digest_text,exec_count,
       round(min_latency/1000000,2)      tidb_min_latency_ms,
       round(avg_latency/1000000,2)      tidb_avg_latency_ms,
       round(max_latency/1000000,2)      tidb_max_latency_ms,
       round(avg_kv_time/1000000,2)      tidb_avg_kv_time_ms,
       round(avg_pd_time/1000000,2)      tidb_avg_pd_time_ms,
       avg_mem/1024/1024                 tidb_avg_mem_mb,
       max_mem/1024/1024                 tidb_max_mem_mb, 
       avg_disk/1024/1024                tidb_avg_disk_mb, 
       max_disk/1024/1024                tidb_max_disk_mb,            
       sum_cop_task_num                  tikv_cop_request_cnt,
       avg_processed_keys                tikv_cop_avg_processed_keys,
       max_processed_keys                tikv_cop_max_processed_keys,    
       avg_total_keys                    tikv_cop_avg_total_keys,
       max_total_keys                    tikv_cop_max_total_keys,     
       round(avg_process_time/1000000,2) tikv_avg_process_time_ms,
    round(max_process_time/1000000,2) tikv_max_process_time_ms,    
    round(avg_wait_time/1000000,2)    tikv_avg_sql_wait_time_ms,
       round(max_wait_time/1000000,2)    tikv_max_sql_wait_time_ms
from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY_HISTORY 
where SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
      and schema_name is not null 
      and stmt_type in ('Select','Update','Delete','Insert')
order by tikv_cop_max_processed_keys desc
limit 5 \G"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

    echo "****************************** Check through the CLUSTER_SLOW_QUERY ******************************"
    $DBUSER -e 2>/dev/null "select  db,digest,
        round(sum(query_time)*1000/count(*),2)     avg_query_time_ms,
        round(sum(Parse_time)*1000/count(*),2)     avg_Parse_time_ms,   
        round(sum(Compile_time)*1000/count(*),2)   avg_Compile_time_ms,
        round(sum(Optimize_time)*1000/count(*),2)  avg_Optimize_time_ms,
        round(sum(Prewrite_time)*1000/count(*),2)  avg_Prewrite_time_ms,
        round(sum(cop_time)*1000/count(*),2)       avg_cop_time_ms,
        round(sum(process_time)*1000/count(*),2)   avg_process_time_ms,
        round(sum(Total_keys)/count(*),2)          avg_Total_keys,
        round(sum(process_keys)/count(*),2)        avg_process_keys,
        round(sum(mem_max)/count(*),2)             avg_mem_max,
        round(sum(disk_max)/count(*),2)            avg_disk_max,
        query
from INFORMATION_SCHEMA.CLUSTER_SLOW_QUERY 
where time between '${start_time}' and '${end_time}'
group by db,digest,query
order by Total_keys desc
limit 5 \G"
      if [ "$?" -gt "0" ]; then
         echo "Execution Failed!"
      fi
      $ECHO



exit 0
fi


#############################################################################################
if [ "$1" = "top_fre_sql" -o "$1" = "tfs" ]; then
start_time=""
end_time=""
# 提示用户输入开始时间，默认为半小时前
read -p "请输入开始时间（留空则默认为半小时前:$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")）: " start_time_input
# 如果用户未输入，则默认为半小时前
if [ -z "$start_time_input" ]; then
    start_time=$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    start_time=$(date -d "$start_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "开始时间：$start_time"

# 提示用户输入结束时间，默认为当前时间
read -p "请输入结束时间（留空则默认为当前时间:$(date "+%Y-%m-%d %H:%M:%S")）: " end_time_input
# 如果用户未输入，则默认为当前时间
if [ -z "$end_time_input" ]; then
    end_time=$(date "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    end_time=$(date -d "$end_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "结束时间：$end_time"
    echo "************************************** Through the view CLUSTER_SLOW_QUERY! **************************************"
    $DBUSER -e 2>/dev/null "select digest,
count(digest),
min(query) 
from INFORMATION_SCHEMA.CLUSTER_SLOW_QUERY
WHERE Time > '${start_time}'
AND time < '${end_time}'  
group by digest 
order by count(digest) desc 
limit 5 \G"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

    echo "************************************** Through the view CLUSTER_STATEMENTS_SUMMARY! **************************************"
    $DBUSER -e 2>/dev/null "select DIGEST,DIGEST_TEXT,EXEC_COUNT from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY order by EXEC_COUNT desc limit 5 \G"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi


exit 0
fi

#############################################################################################
if [ "$1" = "sql_full_scan" -o "$1" = "sfs" ]; then
start_time=""
end_time=""
# 提示用户输入开始时间，默认为半小时前
read -p "请输入开始时间（留空则默认为半小时前:$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")）: " start_time_input
# 如果用户未输入，则默认为半小时前
if [ -z "$start_time_input" ]; then
    start_time=$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    start_time=$(date -d "$start_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "开始时间：$start_time"

# 提示用户输入结束时间，默认为当前时间
read -p "请输入结束时间（留空则默认为当前时间:$(date "+%Y-%m-%d %H:%M:%S")）: " end_time_input
# 如果用户未输入，则默认为当前时间
if [ -z "$end_time_input" ]; then
    end_time=$(date "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    end_time=$(date -d "$end_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "结束时间：$end_time"
    echo "****************************** Check through the STATEMENTS_SUMMARY ******************************"
    $DBUSER -e 2>/dev/null "select schema_name,digest,digest_text,exec_count,
       round(min_latency/1000000,2)         tidb_min_latency_ms,
       round(avg_latency/1000000,2)         tidb_avg_latency_ms,
       round(max_latency/1000000,2)         tidb_max_latency_ms,
       round(avg_kv_time/1000000,2)         tidb_avg_kv_time_ms,
       round(avg_pd_time/1000000,2)         tidb_avg_pd_time_ms,   
       avg_mem/1024/1024                    tidb_avg_mem_mb,
       max_mem/1024/1024                    tidb_max_mem_mb, 
       avg_disk/1024/1024                   tidb_avg_disk_mb, 
       max_disk/1024/1024                   tidb_max_disk_mb,                       
       sum_cop_task_num                     tikv_cop_request_cnt,
       avg_processed_keys                   tikv_cop_avg_processed_keys,
       max_processed_keys                   tikv_cop_max_processed_keys,    
       avg_total_keys                       tikv_cop_avg_total_keys,
       max_total_keys                       tikv_cop_max_total_keys,     
       round(avg_process_time/1000000,2)    tikv_avg_process_time_ms,
       round(max_process_time/1000000,2)    tikv_max_process_time_ms,    
       round(avg_wait_time/1000000,2)       tikv_avg_sql_wait_time_ms,
       round(max_wait_time/1000000,2)       tikv_max_sql_wait_time_ms
from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY 
where SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
      and schema_name is not null 
      and stmt_type in ('Select','Update','Delete','Insert')
      and plan like '%TableFullScan%' 
union
select schema_name,digest,digest_text,exec_count,
       round(min_latency/1000000,2)      tidb_min_latency_ms,
       round(avg_latency/1000000,2)      tidb_avg_latency_ms,
       round(max_latency/1000000,2)      tidb_max_latency_ms,
       round(avg_kv_time/1000000,2)      tidb_avg_kv_time_ms,
       round(avg_pd_time/1000000,2)      tidb_avg_pd_time_ms,
       avg_mem/1024/1024                 tidb_avg_mem_mb,
       max_mem/1024/1024                 tidb_max_mem_mb, 
       avg_disk/1024/1024                tidb_avg_disk_mb, 
       max_disk/1024/1024                tidb_max_disk_mb,            
       sum_cop_task_num                  tikv_cop_request_cnt,
       avg_processed_keys                tikv_cop_avg_processed_keys,
       max_processed_keys                tikv_cop_max_processed_keys,    
       avg_total_keys                    tikv_cop_avg_total_keys,
       max_total_keys                    tikv_cop_max_total_keys,     
       round(avg_process_time/1000000,2) tikv_avg_process_time_ms,
    round(max_process_time/1000000,2) tikv_max_process_time_ms,    
    round(avg_wait_time/1000000,2)    tikv_avg_sql_wait_time_ms,
       round(max_wait_time/1000000,2)    tikv_max_sql_wait_time_ms
from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY_HISTORY 
where SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
      and schema_name is not null 
      and stmt_type in ('Select','Update','Delete','Insert')
order by tidb_avg_latency_ms desc
limit 5;"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

    echo "****************************** Check through the CLUSTER_SLOW_QUERY ******************************"
    $DBUSER -e 2>/dev/null "select  db,digest,
        round(sum(query_time)*1000/count(*),2)     avg_query_time_ms,
        round(sum(Parse_time)*1000/count(*),2)     avg_Parse_time_ms,   
        round(sum(Compile_time)*1000/count(*),2)   avg_Compile_time_ms,
        round(sum(Optimize_time)*1000/count(*),2)  avg_Optimize_time_ms,
        round(sum(Prewrite_time)*1000/count(*),2)  avg_Prewrite_time_ms,
        round(sum(cop_time)*1000/count(*),2)       avg_cop_time_ms,
        round(sum(process_time)*1000/count(*),2)   avg_process_time_ms,
        round(sum(Total_keys)/count(*),2)          avg_Total_keys,
        round(sum(process_keys)/count(*),2)        avg_process_keys,
        round(sum(mem_max)/count(*),2)             avg_mem_max,
        round(sum(disk_max)/count(*),2)            avg_disk_max,
        query
from INFORMATION_SCHEMA.CLUSTER_SLOW_QUERY 
where time between '${start_time}' and '${end_time}'
      and plan like '%TableFullScan%' 
group by db,digest,query
order by avg_query_time_ms desc
limit 5;"
      if [ "$?" -gt "0" ]; then
         echo "Execution Failed!"
      fi
      $ECHO

exit 0
fi


#############################################################################################
if [ "$1" = "top_mem_sql" -o "$1" = "tms" ]; then
start_time=""
end_time=""
# 提示用户输入开始时间，默认为半小时前
read -p "请输入开始时间（留空则默认为半小时前:$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")）: " start_time_input
# 如果用户未输入，则默认为半小时前
if [ -z "$start_time_input" ]; then
    start_time=$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    start_time=$(date -d "$start_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "开始时间：$start_time"

# 提示用户输入结束时间，默认为当前时间
read -p "请输入结束时间（留空则默认为当前时间:$(date "+%Y-%m-%d %H:%M:%S")）: " end_time_input
# 如果用户未输入，则默认为当前时间
if [ -z "$end_time_input" ]; then
    end_time=$(date "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    end_time=$(date -d "$end_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "结束时间：$end_time"
    echo "****************************** Check through the STATEMENTS_SUMMARY ******************************"
    $DBUSER -e 2>/dev/null "select schema_name,digest,digest_text,exec_count,
       round(min_latency/1000000,2)         tidb_min_latency_ms,
       round(avg_latency/1000000,2)         tidb_avg_latency_ms,
       round(max_latency/1000000,2)         tidb_max_latency_ms,
       round(avg_kv_time/1000000,2)         tidb_avg_kv_time_ms,
       round(avg_pd_time/1000000,2)         tidb_avg_pd_time_ms,   
       avg_mem/1024/1024                    tidb_avg_mem_mb,
       max_mem/1024/1024                    tidb_max_mem_mb, 
       avg_disk/1024/1024                   tidb_avg_disk_mb, 
       max_disk/1024/1024                   tidb_max_disk_mb,                       
       sum_cop_task_num                     tikv_cop_request_cnt,
       avg_processed_keys                   tikv_cop_avg_processed_keys,
       max_processed_keys                   tikv_cop_max_processed_keys,    
       avg_total_keys                       tikv_cop_avg_total_keys,
       max_total_keys                       tikv_cop_max_total_keys,     
       round(avg_process_time/1000000,2)    tikv_avg_process_time_ms,
       round(max_process_time/1000000,2)    tikv_max_process_time_ms,    
       round(avg_wait_time/1000000,2)       tikv_avg_sql_wait_time_ms,
       round(max_wait_time/1000000,2)       tikv_max_sql_wait_time_ms
from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY 
where SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
      and schema_name is not null 
      and stmt_type in ('Select','Update','Delete','Insert')
union
select schema_name,digest,digest_text,exec_count,
       round(min_latency/1000000,2)      tidb_min_latency_ms,
       round(avg_latency/1000000,2)      tidb_avg_latency_ms,
       round(max_latency/1000000,2)      tidb_max_latency_ms,
       round(avg_kv_time/1000000,2)      tidb_avg_kv_time_ms,
       round(avg_pd_time/1000000,2)      tidb_avg_pd_time_ms,
       avg_mem/1024/1024                 tidb_avg_mem_mb,
       max_mem/1024/1024                 tidb_max_mem_mb, 
       avg_disk/1024/1024                tidb_avg_disk_mb, 
       max_disk/1024/1024                tidb_max_disk_mb,            
       sum_cop_task_num                  tikv_cop_request_cnt,
       avg_processed_keys                tikv_cop_avg_processed_keys,
       max_processed_keys                tikv_cop_max_processed_keys,    
       avg_total_keys                    tikv_cop_avg_total_keys,
       max_total_keys                    tikv_cop_max_total_keys,     
       round(avg_process_time/1000000,2) tikv_avg_process_time_ms,
    round(max_process_time/1000000,2) tikv_max_process_time_ms,    
    round(avg_wait_time/1000000,2)    tikv_avg_sql_wait_time_ms,
       round(max_wait_time/1000000,2)    tikv_max_sql_wait_time_ms
from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY_HISTORY 
where SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
      and schema_name is not null 
      and stmt_type in ('Select','Update','Delete','Insert')
order by tidb_max_mem_mb desc
limit 5 \G"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO


    echo "****************************** Check through the CLUSTER_SLOW_QUERY ******************************"
    $DBUSER -e 2>/dev/null "select  db,digest,
        round(sum(query_time)*1000/count(*),2)     avg_query_time_ms,
        round(sum(Parse_time)*1000/count(*),2)     avg_Parse_time_ms,   
        round(sum(Compile_time)*1000/count(*),2)   avg_Compile_time_ms,
        round(sum(Optimize_time)*1000/count(*),2)  avg_Optimize_time_ms,
        round(sum(Prewrite_time)*1000/count(*),2)  avg_Prewrite_time_ms,
        round(sum(cop_time)*1000/count(*),2)       avg_cop_time_ms,
        round(sum(process_time)*1000/count(*),2)   avg_process_time_ms,
        round(sum(Total_keys)/count(*),2)          avg_Total_keys,
        round(sum(process_keys)/count(*),2)        avg_process_keys,
        round(sum(mem_max)/count(*),2)             avg_mem_max,
        round(sum(disk_max)/count(*),2)            avg_disk_max,
        query
from INFORMATION_SCHEMA.CLUSTER_SLOW_QUERY 
where time between '${start_time}' and '${end_time}'
group by db,digest,query
order by mem_max desc
limit 5 \G"
      if [ "$?" -gt "0" ]; then
         echo "Execution Failed!"
      fi
      $ECHO

exit 0
fi





#############################################################################################
if [ "$1" = "sql_slow_exec_hist" -o "$1" = "sseh" ]; then
# 提示用户输入SQL指纹
read -p "请输入SQL指纹: " sql_digest
start_time=""
end_time=""
# 提示用户输入开始时间，默认为半小时前
read -p "请输入开始时间（留空则默认为半小时前:$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")）: " start_time_input
# 如果用户未输入，则默认为半小时前
if [ -z "$start_time_input" ]; then
    start_time=$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    start_time=$(date -d "$start_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "开始时间：$start_time"

# 提示用户输入结束时间，默认为当前时间
read -p "请输入结束时间（留空则默认为当前时间:$(date "+%Y-%m-%d %H:%M:%S")）: " end_time_input
# 如果用户未输入，则默认为当前时间
if [ -z "$end_time_input" ]; then
    end_time=$(date "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    end_time=$(date -d "$end_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "结束时间：$end_time"


    echo "****************************** Check through the STATEMENTS_SUMMARY ******************************"
    $DBUSER -e 2>/dev/null "SELECT 
    s.Digest,
    substr(s.SUMMARY_BEGIN_TIME,1,16) as SUMMARY_BEGIN_TIME,
    sum(EXEC_COUNT) as exec_count
FROM
    INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY s
WHERE SUMMARY_BEGIN_TIME between '${start_time}' AND '${end_time}'
      and s.Digest='${sql_digest}'
GROUP BY Digest , substr(s.SUMMARY_BEGIN_TIME,1,16)
order by substr(s.SUMMARY_BEGIN_TIME,1,16);"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO


    echo "****************************** Check through the CLUSTER_SLOW_QUERY ******************************"
    $DBUSER -e 2>/dev/null "SELECT 
    s.Digest,
    substr(s.Time,1,16) as time,
    count(*) as exec_count
FROM
    INFORMATION_SCHEMA.CLUSTER_SLOW_QUERY s
WHERE Time >= '${start_time}' AND time <= '${end_time}'
      and s.Digest='${sql_digest}'
GROUP BY Digest , substr(s.Time,1,16)
order by substr(s.Time,1,16);"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

exit 0
fi



#############################################################################################
if [ "$1" = "sql_slow_long" -o "$1" = "ssl" ]; then
start_time=""
end_time=""
# 提示用户输入开始时间，默认为半小时前
read -p "请输入开始时间（留空则默认为半小时前:$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")）: " start_time_input
# 如果用户未输入，则默认为半小时前
if [ -z "$start_time_input" ]; then
    start_time=$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    start_time=$(date -d "$start_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "开始时间：$start_time"

# 提示用户输入结束时间，默认为当前时间
read -p "请输入结束时间（留空则默认为当前时间:$(date "+%Y-%m-%d %H:%M:%S")）: " end_time_input
# 如果用户未输入，则默认为当前时间
if [ -z "$end_time_input" ]; then
    end_time=$(date "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    end_time=$(date -d "$end_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "结束时间：$end_time"

    echo "****************************** Check through the STATEMENTS_SUMMARY ******************************"
    $DBUSER -e 2>/dev/null "select schema_name,digest,digest_text,exec_count,
       round(min_latency/1000000,2)         tidb_min_latency_ms,
       round(avg_latency/1000000,2)         tidb_avg_latency_ms,
       round(max_latency/1000000,2)         tidb_max_latency_ms,
       round(avg_kv_time/1000000,2)         tidb_avg_kv_time_ms,
       round(avg_pd_time/1000000,2)         tidb_avg_pd_time_ms,   
       avg_mem/1024/1024                    tidb_avg_mem_mb,
       max_mem/1024/1024                    tidb_max_mem_mb, 
       avg_disk/1024/1024                   tidb_avg_disk_mb, 
       max_disk/1024/1024                   tidb_max_disk_mb,                       
       sum_cop_task_num                     tikv_cop_request_cnt,
       avg_processed_keys                   tikv_cop_avg_processed_keys,
       max_processed_keys                   tikv_cop_max_processed_keys,    
       avg_total_keys                       tikv_cop_avg_total_keys,
       max_total_keys                       tikv_cop_max_total_keys,     
       round(avg_process_time/1000000,2)    tikv_avg_process_time_ms,
       round(max_process_time/1000000,2)    tikv_max_process_time_ms,    
       round(avg_wait_time/1000000,2)       tikv_avg_sql_wait_time_ms,
       round(max_wait_time/1000000,2)       tikv_max_sql_wait_time_ms
from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY 
where SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
      and schema_name is not null 
      and stmt_type in ('Select','Update','Delete','Insert')
union
select schema_name,digest,digest_text,exec_count,
       round(min_latency/1000000,2)      tidb_min_latency_ms,
       round(avg_latency/1000000,2)      tidb_avg_latency_ms,
       round(max_latency/1000000,2)      tidb_max_latency_ms,
       round(avg_kv_time/1000000,2)      tidb_avg_kv_time_ms,
       round(avg_pd_time/1000000,2)      tidb_avg_pd_time_ms,
       avg_mem/1024/1024                 tidb_avg_mem_mb,
       max_mem/1024/1024                 tidb_max_mem_mb, 
       avg_disk/1024/1024                tidb_avg_disk_mb, 
       max_disk/1024/1024                tidb_max_disk_mb,            
       sum_cop_task_num                  tikv_cop_request_cnt,
       avg_processed_keys                tikv_cop_avg_processed_keys,
       max_processed_keys                tikv_cop_max_processed_keys,    
       avg_total_keys                    tikv_cop_avg_total_keys,
       max_total_keys                    tikv_cop_max_total_keys,     
       round(avg_process_time/1000000,2) tikv_avg_process_time_ms,
    round(max_process_time/1000000,2) tikv_max_process_time_ms,    
    round(avg_wait_time/1000000,2)    tikv_avg_sql_wait_time_ms,
       round(max_wait_time/1000000,2)    tikv_max_sql_wait_time_ms
from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY_HISTORY 
where SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
      and schema_name is not null 
      and stmt_type in ('Select','Update','Delete','Insert')
order by tikv_avg_process_time_ms desc
limit 5 \G"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO


    echo "****************************** Check through the CLUSTER_SLOW_QUERY ******************************"
    $DBUSER -e 2>/dev/null "SELECT max(query_time),db,query,plan_digest,digest 
FROM INFORMATION_SCHEMA.CLUSTER_SLOW_QUERY
WHERE Is_internal=0 and Time > '${start_time}' AND time < '${end_time}'
GROUP BY db,query,plan_digest,digest 
ORDER BY max(query_time) DESC limit 2 \G"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

exit 0
fi





#############################################################################################
if [ "$1" = "sql_plan_change" -o "$1" = "spc" ]; then
start_time=""
end_time=""
# 提示用户输入开始时间，默认为半小时前
read -p "请输入开始时间（留空则默认为半小时前:$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")）: " start_time_input
# 如果用户未输入，则默认为半小时前
if [ -z "$start_time_input" ]; then
    start_time=$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    start_time=$(date -d "$start_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "开始时间：$start_time"

# 提示用户输入结束时间，默认为当前时间
read -p "请输入结束时间（留空则默认为当前时间:$(date "+%Y-%m-%d %H:%M:%S")）: " end_time_input
# 如果用户未输入，则默认为当前时间
if [ -z "$end_time_input" ]; then
    end_time=$(date "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    end_time=$(date -d "$end_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "结束时间：$end_time"

    echo "****************************** Check through the STATEMENTS_SUMMARY ******************************"
    $DBUSER -e 2>/dev/null "select DIGEST,instance,count(distinct PLAN_DIGEST) plan_cnt 
from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY
where SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'  
group by DIGEST,instance 
having count(distinct PLAN_DIGEST)>1
order by 3 desc 
limit 5;"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO


    echo "****************************** Check through the CLUSTER_SLOW_QUERY ******************************"
    $DBUSER -e 2>/dev/null "SELECT digest, count(distinct(plan_digest)) plan_digest_cnt, min(query) query
FROM INFORMATION_SCHEMA.CLUSTER_SLOW_QUERY
WHERE digest IN (
SELECT digest
FROM INFORMATION_SCHEMA.CLUSTER_SLOW_QUERY
WHERE Time > '${start_time}' AND time < '${end_time}'
GROUP BY digest
ORDER BY sum(Request_count) DESC
LIMIT 10)
group by digest  
having count(distinct(plan_digest)) > 1;"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

exit 0
fi


#############################################################################################
if [ "$1" = "sql_text" -o "$1" = "text" ]; then

# 提示用户输入SQL指纹
read -p "请输入SQL指纹: " sql_digest

    $DBUSER -e 2>/dev/null "SELECT tidb_decode_sql_digests('[\"$sql_digest\"]');";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

exit 0
fi






#############################################################################################
if [ "$1" = "hot_read_write" -o "$1" = "hrw" ]; then

    echo "=========================== the object hot read or write ==========================="
    $DBUSER -e 2>/dev/null "select db_name,table_name,index_name,
      type,
      sum(flow_bytes) flow_bytes_per_minute,
      count(1) region_cnt,group_concat(h.region_id) region_ids,
      count(distinct p.store_id) store_cnt,group_concat(p.store_id) store_ids
from information_schema.tidb_hot_regions h
     join information_schema.tikv_region_peers p on h.region_id=p.region_id and p.is_leader=1
group by db_name,table_name,index_name,type
order by sum(flow_bytes) desc
limit 5;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

    echo ''
    echo ''
    echo "=========================== the tikv hot read or write ==========================="
    $DBUSER -e 2>/dev/null "SELECT
        ss.ADDRESS,
        h.type,
        p.store_id,
        sum(FLOW_BYTES),
        count(1),
        count(DISTINCT p.store_id),
        group_concat(p.region_id)  
FROM information_schema.TIDB_HOT_REGIONS h
JOIN information_schema.tikv_region_peers p ON h.region_id = p.region_id
AND p.IS_LEADER = 1
JOIN information_schema.TIKV_STORE_STATUS ss ON p.store_id = ss.store_id
GROUP BY
        h.type,
        p.store_id,
        ss.ADDRESS
ORDER BY
        sum(FLOW_BYTES) DESC limit 10;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO    




exit 0
fi



#############################################################################################
if [ "$1" = "hot_tikv_store" -o "$1" = "hts" ]; then

    $DBUSER -e 2>/dev/null "select p.store_id,
       sum(flow_bytes) tikv_flow_bytes,
       count(1) region_cnt
from information_schema.tidb_hot_regions h 
     join information_schema.tikv_region_peers p on h.region_id=p.region_id and p.is_leader=1
group by p.store_id
order by 2 desc
limit 5;";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

exit 0
fi



#############################################################################################
if [ "$1" = "var" -o "$1" = "par" ]; then
  if [ "$2" = "" ]; then
     echo "Please enter parameters!"
     echo "E.G: mt var <variables>"
   else
    $DBUSER -e 2>/dev/null "show variables like '%$2%';";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO
  fi

exit 0
fi



#############################################################################################
if [ "$1" = "config" -o "$1" = "conf" ]; then
  if [ "$2" = "" -o "$3" = "" ]; then
     echo "Please enter component name and var name!"
     echo "E.G: mt config <comp_name[pd/tidb/tikv/tiflash/all]> <varialbes>"
   else
    if [ "$2" = "pd" ]; then
       $DBUSER -e 2>/dev/null "show config where type='pd' and name like '%$3%';";
       if [ "$?" -gt "0" ]; then
          echo "Execution Failed!"
       fi
       $ECHO
    elif [ "$2" = "tidb" ]; then
       $DBUSER -e 2>/dev/null "show config where type='tidb' and name like '%$3%';";
       if [ "$?" -gt "0" ]; then
          echo "Execution Failed!"
       fi
       $ECHO
    elif [ "$2" = "tikv" ]; then
       $DBUSER -e 2>/dev/null "show config where type='tikv' and name like '%$3%';";
       if [ "$?" -gt "0" ]; then
          echo "Execution Failed!"
       fi
       $ECHO
    elif [ "$2" = "tiflash" ]; then
       $DBUSER -e 2>/dev/null "show config where type='tiflash' and name like '%$3%';";
       if [ "$?" -gt "0" ]; then
          echo "Execution Failed!"
       fi
       $ECHO
    else
       $DBUSER -e 2>/dev/null "show config where name like '%$3%';";
       if [ "$?" -gt "0" ]; then
          echo "Execution Failed!"
       fi
       $ECHO
    fi
  fi

exit 0
fi







#############################################################################################
if [ "$1" = "top_time_noidx_sql" -o "$1" = "ttns" ]; then
    $DBUSER -e 2>/dev/null "SELECT schema_name,digest,
       FLOOR(UNIX_TIMESTAMP(MIN(summary_begin_time))) AS agg_begin_time, 
       FLOOR(UNIX_TIMESTAMP(MAX(summary_end_time))) AS agg_end_time, 
			 ANY_VALUE(digest_text) AS agg_digest_text, 
			 ANY_VALUE(digest) AS agg_digest, 
			 SUM(exec_count) AS agg_exec_count, 
			 SUM(sum_latency) AS agg_sum_latency, 
			 MAX(max_latency) AS agg_max_latency, 
			 MIN(min_latency) AS agg_min_latency, 
			 CAST( SUM(exec_count * avg_latency)/SUM(exec_count) AS SIGNED ) AS agg_avg_latency, 
			 CAST( SUM(exec_count * avg_mem)/SUM(exec_count) AS SIGNED ) AS agg_avg_mem, 
			 MAX(max_mem) AS agg_max_mem, 
			 ANY_VALUE(schema_name) AS agg_schema_name, 
			 ANY_VALUE(plan_digest) AS agg_plan_digest,
			 query_sample_text,index_names 
FROM INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY_HISTORY 
where index_names is null and query_sample_text is not null
GROUP BY schema_name,digest,QUERY_SAMPLE_TEXT,INDEX_NAMES 
ORDER BY agg_sum_latency DESC 
limit 5 \G";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO
exit 0
fi

#############################################################################################
if [ "$1" = "top_time_high_fre_sql" -o "$1" = "tthfs" ]; then
    $DBUSER -e 2>/dev/null "SELECT FLOOR(UNIX_TIMESTAMP(MIN(summary_begin_time))) AS agg_begin_time, 
        FLOOR(UNIX_TIMESTAMP(MAX(summary_end_time))) AS agg_end_time, 
				ANY_VALUE(digest_text) AS agg_digest_text, 
				ANY_VALUE(digest) AS agg_digest, 
				SUM(exec_count) AS agg_exec_count, 
				SUM(sum_latency) AS agg_sum_latency, 
				MAX(max_latency) AS agg_max_latency, 
				MIN(min_latency) AS agg_min_latency, 
				CAST( SUM(exec_count * avg_latency) / SUM(exec_count) AS SIGNED ) AS agg_avg_latency, 
				CAST( SUM(exec_count * avg_mem) / SUM(exec_count) AS SIGNED ) AS agg_avg_mem, 
				MAX(max_mem) AS agg_max_mem, 
				ANY_VALUE(schema_name) AS agg_schema_name, 
				ANY_VALUE(plan_digest) AS agg_plan_digest,
				query_sample_text,index_names 
FROM INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY_HISTORY 
GROUP BY schema_name, digest,QUERY_SAMPLE_TEXT,INDEX_NAMES
ORDER BY agg_sum_latency DESC 
limit 5 \G";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO
exit 0
fi


#############################################################################################
if [ "$1" = "top_slow_query_sql" -o "$1" = "tsqs" ]; then

start_time=""
end_time=""
# 提示用户输入开始时间，默认为半小时前
read -p "请输入开始时间（留空则默认为半小时前:$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")）: " start_time_input
# 如果用户未输入，则默认为半小时前
if [ -z "$start_time_input" ]; then
    start_time=$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    start_time=$(date -d "$start_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "开始时间：$start_time"

# 提示用户输入结束时间，默认为当前时间
read -p "请输入结束时间（留空则默认为当前时间:$(date "+%Y-%m-%d %H:%M:%S")）: " end_time_input
# 如果用户未输入，则默认为当前时间
if [ -z "$end_time_input" ]; then
    end_time=$(date "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    end_time=$(date -d "$end_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "结束时间：$end_time"


##==============================================================================================
## 执行
##==============================================================================================

target_query="select Digest,
query sql_text,mnt as executions,avg_query_time,
(case when avg_proc_time=0 then 'point_get' when avg_proc_time>avg_wait_time then 'coprocessor_process' else 'coprocessor_wait' end) as type,
avg_proc_time,avg_wait_time,max_query_time
from (
select digest,substr(query,1,100) query,count(*) mnt,avg(query_time) avg_query_time ,avg(process_time) avg_proc_time,avg(wait_time) avg_wait_time,max(query_time) max_query_time
from information_schema.cluster_slow_query
where time >='$start_time'
and time <= '$end_time'
and lower(query) not like 'analyze%'
or lower(query) not like 'alter%'
group by digest,substr(query,1,100)
) t
order by 
executions desc,
avg_query_time desc
limit 20;"

#echo "$query_result"
$DBUSER -e 2>/dev/null "$target_query" -t 
 

exit 0
fi


#############################################################################################
if [ "$1" = "sql_diag_analysis" -o "$1" = "sda" ]; then
read -p "input the sql DIGEST :" digest

sqldate=`date +%Y%m%d%H%M%S`
tab_names_file=tab_names_file_`date +%Y%m%d%H%M%S`.txt
tab_names=/tmp/${tab_names_file} 
sqlonekeyinfo_file=sqlonekeyinfo_$digest_`date +%Y%m%d%H%M%S`.txt
sqlonekeyinfo=/tmp/${sqlonekeyinfo_file} 
 
# echo   "sqlonekeyinfo file :" $sqlonekeyinfo
#sqlhist
sqlcommand="SELECT SUMMARY_BEGIN_TIME as begin_time,SUMMARY_END_TIME as end_time,PLAN_DIGEST,EXEC_COUNT as execs ,AVG_RESULT_ROWS as avg_rows,
AVG_LATENCY/1000000000 as avg_ela,AVG_PROCESSED_KEYS as avg_pro_key from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY
WHERE DIGEST='"${digest}"' or
(substr(DIGEST,1,5) = substr('"${digest}"',1,5)
 and  substr(DIGEST,31,4) = substr('"${digest}"',6,4)
 and  substr(DIGEST,61,4)= substr('"${digest}"',10,4) )
UNION
SELECT SUMMARY_BEGIN_TIME as begin_time,SUMMARY_END_TIME as end_time,PLAN_DIGEST,EXEC_COUNT as execs ,AVG_RESULT_ROWS as avg_rows,
AVG_LATENCY/1000000000 as avg_ela,AVG_PROCESSED_KEYS as avg_pro_key
FROM INFORMATION_SCHEMA.cluster_statements_summary_history
WHERE DIGEST='"${digest}"' or
(substr(DIGEST,1,5) = substr('"${digest}"',1,5)
 and  substr(DIGEST,31,4) = substr('"${digest}"',6,4)
 and  substr(DIGEST,61,4)= substr('"${digest}"',10,4) ) order by begin_time"

echo "========= SQL HIST =========" >> $sqlonekeyinfo
$DBUSER -e 2>/dev/null "$sqlcommand" -t >> $sqlonekeyinfo

#sql plan display
sqlcommand1="
select  
min(plan),
plan_digest,
 min(first_seen),
 max(last_seen),
 sum(exec_count)
from  INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY 
 where  DIGEST ='"${digest}"' 
 or
 ( substr(DIGEST,1,5) = substr('"${digest}"',1,5)
 and  substr(DIGEST,31,4) = substr('"${digest}"',6,4)
 and  substr(DIGEST,61,4)= substr('"${digest}"',10,4) 
 )  group by plan_digest
 union
select  
min(plan),
plan_digest,
 min(first_seen),
 max(last_seen),
 sum(exec_count)
from  INFORMATION_SCHEMA.cluster_statements_summary_history 
 where  DIGEST ='"${digest}"' 
 or
 ( substr(DIGEST,1,5) = substr('"${digest}"',1,5)
 and  substr(DIGEST,31,4) = substr('"${digest}"',6,4)
 and  substr(DIGEST,61,4)= substr('"${digest}"',10,4) 
 )  group by plan_digest
\G"

 
echo " " >> $sqlonekeyinfo
echo "========= SQL PLAN =========" >> $sqlonekeyinfo
$DBUSER -e 2>/dev/null "$sqlcommand1" -t >> $sqlonekeyinfo

#get table status
##定义函数get_tabstatus获取表的各种状态数据
get_tabstatus(){
sqlcmd_tabstatus2="select a.TABLE_SCHEMA,a.TABLE_NAME,b.modify_count,b.count, case when b.count is null then 'NO_STATS' else   
round(1-b.modify_count/if(b.count=0,1,b.count))*100 end as Healthy,tidb_parse_tso(b.version) as Update_time from  INFORMATION_SCHEMA.tables a left join mysql.stats_meta b on a.TIDB_TABLE_ID=b.table_id
where  concat(upper(a.TABLE_SCHEMA),'.',upper(a.TABLE_NAME))=upper('$schemaname_tablename')"

sqlcmd_tabstatus3="SELECT a.TABLE_SCHEMA,a.TABLE_NAME,a.TABLE_ROWS,b.COLUMN_NAME,c.distinct_count FROM INFORMATION_SCHEMA.tables a left join INFORMATION_SCHEMA.COLUMNS b on a.TABLE_NAME=b.TABLE_NAME AND a.TABLE_SCHEMA =b.TABLE_SCHEMA
left join  mysql.stats_histograms c on a.TIDB_TABLE_ID=c.table_id
WHERE  b.ORDINAL_POSITION=c.hist_id and concat(upper(a.TABLE_SCHEMA),'.',upper(a.TABLE_NAME))=upper('$schemaname_tablename')
AND c.is_index=0 ORDER BY c.hist_id"

sqlcmd_tabstatus4="select TABLE_SCHEMA,TABLE_NAME,KEY_NAME,COLUMN_NAME,IS_VISIBLE,CLUSTERED from INFORMATION_SCHEMA.TIDB_INDEXES a
where concat(upper(a.TABLE_SCHEMA),'.',upper(a.TABLE_NAME))=upper('$schemaname_tablename')"

sqlcmd_tabstatus5="SELECT DB_NAME as TABLE_SCHEMA,TABLE_NAME,JOB_TYPE,CREATE_TIME,START_TIME,END_TIME from INFORMATION_SCHEMA.DDL_JOBS a where concat(upper(a.DB_NAME),'.',upper(a.TABLE_NAME))=upper('$schemaname_tablename')
order by CREATE_TIME desc limit 10"

sqlcmd_tabstatus6="SELECT  db_name , table_name , INDEX_NAME,ROUND(SUM(total_size / cnt), 2) Approximate_Size_MB , ROUND(SUM(total_size/cnt/( SELECT ROUND(AVG(value), 2) FROM METRICS_SCHEMA.store_size_amplification WHERE value > 0 ) ), 2) Disk_Size_MB
FROM   ( SELECT db_name , table_name ,INDEX_NAME, region_id , SUM(Approximate_Size) total_size , COUNT(*) cnt FROM information_schema.TIKV_REGION_STATUS
WHERE  concat(upper(DB_NAME),'.',upper(TABLE_NAME))=upper('$schemaname_tablename')
GROUP BY db_name , table_name ,INDEX_NAME, region_id ) tabinfo  GROUP BY db_name , table_name,INDEX_NAME order by db_name,table_name,index_name"

USERNAME=`whoami`
echo "========= tab statistics information ========="  
$DBUSER -e 2>/dev/null "$sqlcmd_tabstatus2" -t  
echo "========= col information ========="  
$DBUSER -e 2>/dev/null"$sqlcmd_tabstatus3" -t  
echo "========= index information ========="  
$DBUSER -e 2>/dev/null "$sqlcmd_tabstatus4" -t  
echo "========= tab ddl information ========="  
$DBUSER -e 2>/dev/null "$sqlcmd_tabstatus5" -t  
echo "========= tab size from TIKV_REGION_STATUS =========" 
$DBUSER -e 2>/dev/null "$sqlcmd_tabstatus6" -t  
}

##get table_names
sqlcommand_gettabname="
select table_names from information_schema.cluster_statements_summary where 
 DIGEST ='"${digest}"' 
 or
(substr(DIGEST,1,5) = substr('"${digest}"',1,5)
 and  substr(DIGEST,31,4) = substr('"${digest}"',6,4)
 and  substr(DIGEST,61,4)= substr('"${digest}"',10,4) )
union all
select table_names from information_schema.cluster_statements_summary_history where 
 DIGEST ='"${digest}"' 
 or
(substr(DIGEST,1,5) = substr('"${digest}"',1,5)
 and  substr(DIGEST,31,4) = substr('"${digest}"',6,4)
 and  substr(DIGEST,61,4)= substr('"${digest}"',10,4) ) limit 1;
 "



USERNAME=`whoami`
if [ ! -n "$digest" ];then
echo "No digest"
exit
else 
  $DBUSER -s -Ne 2>/dev/null "$sqlcommand_gettabname"   > $tab_names
  #将表名做换行处理
  sed 's/,/\n/g'  -i $tab_names  
fi
 
#循环读取表名，获取表的相关信息
 while IFS= read -r line
 do
 echo " " >> $sqlonekeyinfo
 echo "------------------------------------------- "$line" status -------------------------------------------" >> $sqlonekeyinfo
 schemaname_tablename=$line
 get_tabstatus >> $sqlonekeyinfo ;   
 done < $tab_names

echo " " >> $sqlonekeyinfo
# echo "sqlonekeyinfo file lines:"
wc -l  $sqlonekeyinfo
echo ""
#   echo "sqlonekey info :"
   cat $sqlonekeyinfo
exit 0
fi


#############################################################################################
if [ "$1" = "sql_exec_detail" -o "$1" = "sed" ]; then
  read -p "input the sql DIGEST :" v_sql_id
  echo '======================================== SQL Execution Detail Part1 ========================================'
  $DBUSER -e 2>/dev/null "SELECT first_seen,last_seen,PLAN_DIGEST,EXEC_COUNT as execs ,AVG_RESULT_ROWS as avg_rows,
AVG_LATENCY/1000000000 as avg_ela,AVG_PROCESSED_KEYS as avg_pro_key from INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY
WHERE DIGEST='${v_sql_id}' 
UNION
SELECT first_seen,last_seen,PLAN_DIGEST,EXEC_COUNT as execs ,AVG_RESULT_ROWS as avg_rows,
AVG_LATENCY/1000000000 as avg_ela,AVG_PROCESSED_KEYS as avg_pro_key
FROM INFORMATION_SCHEMA.cluster_statements_summary_history
WHERE DIGEST='${v_sql_id}' 
order by 1 
limit 5;";
  if [ "$?" -gt "0" ]; then
     echo "Execution Failed!"
  fi
  $ECHO
  
  echo ''
  echo ''
  echo '======================================== SQL Execution Detail Part1 ========================================'
  $DBUSER -e 2>/dev/null "select  
plan,
plan_digest,
 first_seen,
 last_seen,
 exec_count
from  INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY 
 where  DIGEST ='${v_sql_id}' 
union
select  
plan,
plan_digest,
 first_seen,
 last_seen,
 exec_count
from  INFORMATION_SCHEMA.cluster_statements_summary_history 
 where  DIGEST ='${v_sql_id}' 
\G";
  if [ "$?" -gt "0" ]; then
     echo "Execution Failed!"
  fi
  $ECHO

exit 0
fi



#############################################################################################
if [ "$1" = "sql_search_text" -o "$1" = "sst" ]; then

read -p "input the sqltext other key words:" v_sqltext

start_time=""
end_time=""
# 提示用户输入开始时间，默认为半小时前
read -p "请输入开始时间（留空则默认为半小时前:$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")）: " start_time_input
# 如果用户未输入，则默认为半小时前
if [ -z "$start_time_input" ]; then
    start_time=$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    start_time=$(date -d "$start_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "开始时间：$start_time"

# 提示用户输入结束时间，默认为当前时间
read -p "请输入结束时间（留空则默认为当前时间:$(date "+%Y-%m-%d %H:%M:%S")）: " end_time_input
# 如果用户未输入，则默认为当前时间
if [ -z "$end_time_input" ]; then
    end_time=$(date "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    end_time=$(date -d "$end_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "结束时间：$end_time"



sqlcommand1="
SELECT DATE_FORMAT(TIME,'%Y-%m-%d %H:%i:%s') AS TIME,DIGEST,Query
FROM
INFORMATION_SCHEMA.CLUSTER_SLOW_QUERY
WHERE upper(Query) LIKE upper('"${v_sqltext}"')
      and TIME between '${start_time}' and '${end_time}'
ORDER BY TIME \G"

echo "===============================The Slow query SQL as following ==============================="
$DBUSER -e 2>/dev/null "$sqlcommand1" -t
if [ "$?" -gt "0" ]; then
   echo "Execution Failed!"
fi
$ECHO



sqlcommand2="
SELECT FIRST_SEEN,LAST_SEEN,DIGEST,DIGEST_TEXT FROM INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY
WHERE upper(DIGEST_TEXT) LIKE upper('%${v_sqltext}%')
      and SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
UNION
SELECT FIRST_SEEN,LAST_SEEN,DIGEST,DIGEST_TEXT
FROM INFORMATION_SCHEMA.cluster_statements_summary_history
WHERE SUMMARY_BEGIN_TIME between '${start_time}' and '${end_time}'
      and upper(DIGEST_TEXT) LIKE upper('%${v_sqltext}%') 
order by FIRST_SEEN,LAST_SEEN \G"


echo "===============================The CLUSTER_STATEMENTS_SUMMARY SQL as following ==============================="
$DBUSER -e 2>/dev/null "$sqlcommand2" -t
if [ "$?" -gt "0" ]; then
   echo "Execution Failed!"
fi
$ECHO


exit 0
fi

#############################################################################################
if [ "$1" = "sql_search_digest" -o "$1" = "ssd" ]; then

read -p "input the sql digest :" v_digest

start_time=""
end_time=""
# 提示用户输入开始时间，默认为半小时前
read -p "请输入开始时间（留空则默认为半小时前:$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")）: " start_time_input
# 如果用户未输入，则默认为半小时前
if [ -z "$start_time_input" ]; then
    start_time=$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    start_time=$(date -d "$start_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "开始时间：$start_time"

# 提示用户输入结束时间，默认为当前时间
read -p "请输入结束时间（留空则默认为当前时间:$(date "+%Y-%m-%d %H:%M:%S")）: " end_time_input
# 如果用户未输入，则默认为当前时间
if [ -z "$end_time_input" ]; then
    end_time=$(date "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    end_time=$(date -d "$end_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "结束时间：$end_time"


sqlcommand1="
select DIGEST,
 DIGEST_TEXT
 ,QUERY_SAMPLE_TEXT AS QUERY_TEXT
from  INFORMATION_SCHEMA.CLUSTER_STATEMENTS_SUMMARY 
 where  DIGEST ='${v_digest}' 
 or
 ( substr(DIGEST,1,5) = substr('${v_digest}',1,5)
 and  substr(DIGEST,31,4) = substr('${v_digest}',6,4)
 and  substr(DIGEST,61,4)= substr('${v_digest}',10,4) 
 ) 
 union
 select  
 DIGEST ,
 DIGEST_TEXT
 ,QUERY_SAMPLE_TEXT AS QUERY_TEXT
from  INFORMATION_SCHEMA.cluster_statements_summary_history 
 where  DIGEST ='${v_digest}' 
 or
 ( substr(DIGEST,1,5) = substr('${v_digest}',1,5)
 and  substr(DIGEST,31,4) = substr('${v_digest}',6,4)
 and  substr(DIGEST,61,4)= substr('${v_digest}',10,4) 
 ) 
 union
 select 
 DIGEST ,
 ' ' as DIGEST_TEXT,INFO  AS QUERY_TEXT from INFORMATION_SCHEMA.cluster_processlist
 where DIGEST ='${v_digest}' 
 or
 ( substr(DIGEST,1,5) = substr('${v_digest}',1,5)
 and  substr(DIGEST,31,4) = substr('${v_digest}',6,4)
 and  substr(DIGEST,61,4)= substr('${v_digest}',10,4) 
 ) 
 union 
 select 
 DIGEST ,
 ' ' as DIGEST_TEXT,QUERY  AS QUERY_TEXT
 from information_schema.cluster_slow_query
 where 
 (DIGEST ='${v_digest}' 
 or
 ( substr(DIGEST,1,5) = substr('${v_digest}',1,5)
 and  substr(DIGEST,31,4) = substr('${v_digest}',6,4)
 and  substr(DIGEST,61,4)= substr('${v_digest}',10,4) 
 ) ) 
and  time between '${start_time}' and '${end_time}'
 limit 1"

echo "===============================The SQL AS Following ==============================="
$DBUSER -e 2>/dev/null "$sqlcommand1" -t
if [ "$?" -gt "0" ]; then
   echo "Execution Failed!"
fi
$ECHO

exit 0
fi


#############################################################################################
if [ "$1" = "find_obj" -o "$1" = "fo" ]; then

read -p "input object name key words:" object_name

sqlcommand="
SELECT TABLE_SCHEMA AS schema_name,TABLE_TYPE AS OBJECT_TYPE,TABLE_NAME AS OBJECT_NAME,CREATE_TIME  AS CREATE_TIME
FROM INFORMATION_SCHEMA.tables
WHERE upper(TABLE_NAME) LIKE upper('%$object_name%')
UNION
SELECT TABLE_SCHEMA AS schema_name,'INDEX' AS OBJECT_TYPE,KEY_NAME AS OBJECT_NAME,'' AS CREATE_TIME
FROM INFORMATION_SCHEMA.TIDB_INDEXES
where   upper(KEY_NAME) LIKE upper('%$object_name%')"

$DBUSER -e 2>/dev/null "$sqlcommand" -t
if [ "$?" -gt "0" ]; then
   echo "Execution Failed!"
fi
$ECHO

exit 0
fi


#############################################################################################
if [ "$1" = "sql_binding" -o "$1" = "sb" ]; then

  $DBUSER -e 2>/dev/null "select * from mysql.bind_info \G";
  if [ "$?" -gt "0" ]; then
    echo "Execution Failed!"
  fi
  $ECHO
  

exit 0
fi

#############################################################################################
if [ "$1" = "sql_binding_filter" -o "$1" = "sbf" ]; then

   if [ "$2" = "" ]; then
     echo "Please enter the filter key words!"
     echo "E.G: mt sql_binding_filter[ or sbw] <key_word> "

   else
     $DBUSER -e 2>/dev/null "select * from mysql.bind_info where lower(original_sql) like '%${2,,}%' \G";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
   fi

exit 0
fi


#############################################################################################
if [ "$1" = "sql_binding_enable_stmt" -o "$1" = "sbes" ]; then
   
   read -p "input sql statement(sql_text):" sql_text

   $DBUSER -e 2>/dev/null "set binding enabled for ${sql_text};";
   if [ "$?" -gt "0" ]; then
     echo "Execution Failed!"
   fi
   $ECHO

exit 0
fi

#############################################################################################
if [ "$1" = "sql_binding_disable_stmt" -o "$1" = "sbds" ]; then

   read -p "input sql statement(sql_text):" sql_text

   $DBUSER -e 2>/dev/null "set binding disabled for ${sql_text};";
   if [ "$?" -gt "0" ]; then
     echo "Execution Failed!"
   fi
   $ECHO

exit 0
fi

#############################################################################################
if [ "$1" = "sql_binding_enable_digest" -o "$1" = "sbed" ]; then

   read -p "input sql digest:" sql_digest

   $DBUSER -e 2>/dev/null "set binding enabled for sql digest ${sql_digest};";
   if [ "$?" -gt "0" ]; then
     echo "Execution Failed!"
   fi
   $ECHO

exit 0
fi


#############################################################################################
if [ "$1" = "sql_binding_disable_digest" -o "$1" = "sbdd" ]; then

   read -p "input sql digest:" sql_digest

   $DBUSER -e 2>/dev/null "set binding disabled for sql digest ${sql_digest};";
   if [ "$?" -gt "0" ]; then
     echo "Execution Failed!"
   fi
   $ECHO

exit 0
fi







#############################################################################################
if [ "$1" = "stats_unhealthy_missing" -o "$1" = "sum" ]; then

   echo "================ Table statistics is unhealthy : ================"
   $DBUSER -e 2>/dev/null " select b.TABLE_SCHEMA, 
        b.TABLE_NAME,
				'' as PARTITION_NAME, 
				a.modify_count, 
				a.count,
				round(1-a.modify_count/a.count)*100 as Healthy
 from mysql.stats_meta a,information_schema.tables b
 where a.table_id=b.TIDB_TABLE_ID
       and a.count>1000
       and a.modify_count/count > 0.1
		   and b.TABLE_SCHEMA not in ('PERFORMANCE_SCHEMA','INFORMATION_SCHEMA','mysql','METRICS_SCHEMA')
 union all
 select b.TABLE_SCHEMA, 
        b.TABLE_NAME,
				b.PARTITION_NAME,
				a.modify_count,
				a.count,
				round(1-a.modify_count/a.count)*100 as Healthy
 from mysql.stats_meta a,information_schema.partitions b
 where b.TIDB_PARTITION_ID=a.table_id
       and a.count>1000
       and a.modify_count/count > 0.1
		   and b.TABLE_SCHEMA not in ('PERFORMANCE_SCHEMA','INFORMATION_SCHEMA','mysql','METRICS_SCHEMA');";
   if [ "$?" -gt "0" ]; then
     echo "Execution Failed!"
   fi
   $ECHO
   $ECHO
   echo "================= Table statistics is missing : ================="
   $DBUSER -e 2>/dev/null "select TABLE_SCHEMA,
       TABLE_NAME,
			 table_type,
			 '' as PARTITION_NAME,
			 CREATE_TIME
from information_schema.tables tbl
where tbl.TABLE_TYPE not in ( 'SYSTEM VIEW','VIEW','SEQUENCE')
       and tbl.TABLE_SCHEMA not in ('PERFORMANCE_SCHEMA','INFORMATION_SCHEMA','mysql','METRICS_SCHEMA')
       and not exists (select 1 from mysql.stats_meta sm where tbl.TIDB_TABLE_ID=sm.table_id)
union all
select TABLE_SCHEMA,
       TABLE_NAME,
			 'PARTITION' AS table_type,
			 PARTITION_NAME, 
			 CREATE_TIME
from 	information_schema.partitions ptab 
where ptab.table_schema not in ('PERFORMANCE_SCHEMA','INFORMATION_SCHEMA','mysql','METRICS_SCHEMA')	
       and ptab.TIDB_PARTITION_ID is not null
       and not exists (select 1 from mysql.stats_meta sm where ptab.TIDB_PARTITION_ID=sm.table_id)
order by TABLE_SCHEMA,TABLE_NAME,PARTITION_NAME,CREATE_TIME;";
   if [ "$?" -gt "0" ]; then
     echo "Execution Failed!"
   fi
   $ECHO

exit 0
fi


#############################################################################################
if [ "$1" = "kill_conneciton_id" -o "$1" = "kci" ]; then

         if [ "$2" = "" ]; then
     echo "Please Enter The Connection ID!"
     echo "E.G: mt kill_conneciton_id connection_id"

   else
     $DBUSER -e 2>/dev/null "kill $2;";
     if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
     fi
     $ECHO
   fi

exit 0
fi






#############################################################################################
if [ "$1" = "kill_session_all_select" -o "$1" = "ksas" ]; then

 
read -p "Auto kill select session [YESAUTO/NO] (default NO) :" auto_kill 
auto_kill=${auto_kill:-NO}

echo " "


echo "======================================================"
v_condition="upper(info) like 'SELECT%'  "


#create session kill sql file
kill_sql=/tmp/tidb_kill_`date +%Y%m%d%H%M%S`.sql
sqlcommand="
select concat('KILL TIDB ',ID,';')  from information_schema.cluster_processlist where 
info not like '%concat%KILL%TIDB%' 
and  ${v_condition}
order by time desc;
"

sqlcommand2="
select concat('KILL TIDB ',ID,';',' /* ',user,'@',host,' @',TxnStart,'_',DIGEST,' */') from information_schema.cluster_processlist where 
info not like '%concat%KILL%TIDB%' 
and  ${v_condition}
order by time desc;
"

# tidblogin -e "$sqlcommand" -ss
$DBUSER -e "$sqlcommand2" -ss > ${kill_sql}


#auto_kill 不能为空，需要传值
if [ ! -s ${kill_sql} ] ;then
 echo "=== No session need kill ! === "
else
  if [ $auto_kill = 'YESAUTO' ];then
   $DBUSER < "${kill_sql}" 
   echo " kill all select session  sql statements finished!"
    else
   echo " "
   echo " Exec command to kill all select sql statements sessions  :"
   echo "[   tidblogin < "${kill_sql}"   ] "
   echo "OR"
   echo "[    \.   "${kill_sql}"   ] "
  fi
fi


exit 0
fi




#############################################################################################
if [ "$1" = "kill_session" -o "$1" = "ks" ]; then

echo " "
echo "generate kill session sql statements"

echo "======================================================"

echo "eg: "
echo "1、 user='xxx' "
echo "2、 host like '11.xx.xx%' "
echo "3、 digest like 'xxx%' "
echo "4、 info like 'select xxx from xxx %' "
echo " if you need other column condition ,use \"desc information_schema.cluster_processlist;\" "
echo "======================================================"
read -p "Enter the  conditions: " v_condition
echo " "


#create session kill sql file
kill_sql=/tmp/tidb_kill_`date +%Y%m%d%H%M%S`.sql
sqlcommand="
select concat('KILL TIDB ',ID,';')  from information_schema.cluster_processlist where 
info not like '%concat%KILL%TIDB%' 
and  ${v_condition}
order by time desc;
"

sqlcommand2="
select concat('KILL TIDB ',ID,';',' /* ',user,'@',host,' @',TxnStart,'_',DIGEST,' */') from information_schema.cluster_processlist where 
info not like '%concat%KILL%TIDB%' 
and  ${v_condition}
order by time desc;
"

$DBUSER -e "$sqlcommand" -ss
$DBUSER -e "$sqlcommand2" -ss > ${kill_sql}

echo " "
echo "======================================================"
echo "exec  [ \. "${kill_sql}" ] "

exit 0
fi



#############################################################################################
if [ "$1" = "kill_session_sql_digest" -o "$1" = "kssd" ]; then

read -p "Input sql digest :" digest
echo " "
echo " "
echo "generate kill session sql statements"
echo "======================================================"
sqlcommand="select concat('KILL TIDB ',ID,';') from information_schema.cluster_processlist where DIGEST ='"${digest}"' 
 or
 ( substr(DIGEST,1,5) = substr('"${digest}"',1,5)
 and  substr(DIGEST,31,4) = substr('"${digest}"',6,4)
 and  substr(DIGEST,61,4)= substr('"${digest}"',10,4) 
 ) 
 order by time desc;" 

#create session kill sql file
kill_sql=/tmp/tidb_kill_`date +%Y%m%d%H%M%S`.sql
sqlcommand2="
select concat('KILL TIDB ',ID,';',' /* ',user,'@',host,' @',TxnStart,' */') from information_schema.cluster_processlist where DIGEST ='"${digest}"' 
 or
 ( substr(DIGEST,1,5) = substr('"${digest}"',1,5)
 and  substr(DIGEST,31,4) = substr('"${digest}"',6,4)
 and  substr(DIGEST,61,4)= substr('"${digest}"',10,4) 
 ) 
 order by time desc;
"

$DBUSER -e "$sqlcommand" -ss
$DBUSER -e "$sqlcommand2" -ss > ${kill_sql}

echo " "
echo "======================================================"
echo "exec  [ \. "${kill_sql}" ] "

exit 0
fi





#############################################################################################
if [ "$1" = "gc_blocker" -o "$1" = "gb" ]; then

start_time=""
end_time=""
# 提示用户输入开始时间，默认为半小时前
read -p "请输入开始时间（留空则默认为半小时前:$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")）: " start_time_input
# 如果用户未输入，则默认为半小时前
if [ -z "$start_time_input" ]; then
    start_time=$(date -d '30 minutes ago' "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    start_time=$(date -d "$start_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "开始时间：$start_time"

# 提示用户输入结束时间，默认为当前时间
read -p "请输入结束时间（留空则默认为当前时间:$(date "+%Y-%m-%d %H:%M:%S")）: " end_time_input
# 如果用户未输入，则默认为当前时间
if [ -z "$end_time_input" ]; then
    end_time=$(date "+%Y-%m-%d %H:%M:%S")
else
    # 用户输入不为空，使用用户输入的时间
    end_time=$(date -d "$end_time_input" "+%Y-%m-%d %H:%M:%S")
fi
echo "结束时间：$end_time"



find_alert_query=\
"SELECT message 
FROM INFORMATION_SCHEMA.CLUSTER_LOG
    WHERE message like '%gc safepoint blocked by a running session%' 
    AND time between '${start_time}' and '${end_time}'
    AND type='tidb'
    ORDER BY time DESC
    LIMIT 1;"

alert_text=$($DBUSER -e "$find_alert_query" -ss)


start_ts=$(echo "$alert_text" | sed -nr 's/.*globalMinStartTS=([0-9]+).*/\1/p')


if [[ -z "$start_ts" ]]; then
    echo "没有找到gc_cannot_work告警"
    exit 1
fi

echo "已找到组塞事物，事物id: $start_ts"

find_blocking_transaction_query=\
"SELECT *
FROM INFORMATION_SCHEMA.CLUSTER_PROCESSLIST
WHERE TxnStart like '%$start_ts%'"

txn_info=$($DBUSER -e 2>/dev/null "$find_blocking_transaction_query" -t)

echo "$txn_info"


exit 0
fi



#############################################################################################
if [ "$1" = "pd_leader_change" -o "$1" = "plc" ]; then
echo -e "${RED}*********************************** Need to execute under the tidb user and on tiup host! *********************************** ${RESET}"
read -p "input the tidb cluster name:" cluster_name
DT=`date +%Y%m%d%H%M%S`
echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") 集群pd信息如下:"
$tiupcmd cluster display ${cluster_name} -R pd 

#read -p "请选择目标pd: 例如10.68.36.30:2379" choise
pd_addr=`$tiupcmd cluster display ${cluster_name} -R pd |grep Up|awk  '{print $1}' |tail -1`
cluster_version=`$tiupcmd cluster display ${cluster_name} |grep "Cluster version:"|awk -F ":" '{print $2}'`
version=$(echo $cluster_version | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
echo "$tiupcmd ctl:"${version}" pd -u "${pd_addr}" member |jq '.members[].name'"  >  /tmp/${cluster_name}_pd_member_${DT}.sh
echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") PD 成员信息:" 
cat /tmp/${cluster_name}_pd_member_${DT}.sh
sh /tmp/${cluster_name}_pd_member_${DT}.sh
read -p "请选择新的pd leader:"  choise
echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") 请选择新的pd leader:${choise}"
echo "$tiupcmd ctl:"${version}" pd -u "${pd_addr}" member leader transfer  "${choise}  >  /tmp/${cluster_name}_pd_change_${DT}.sh 
echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") PD Leader切换脚本信息："
cat /tmp/${cluster_name}_pd_change_${DT}.sh
sh /tmp/${cluster_name}_pd_change_${DT}.sh > /tmp/${cluster_name}_pd_change_status_${DT}
pd_leader_change_status=`cat /tmp/${cluster_name}_pd_change_status_${DT}|grep Success|wc -l`
if [ "$pd_leader_change_status" -eq "1" ]; then
   echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") pd leader 切换完成!"
   sleep 10
   echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") 切换后的pd 信息如下："
   $tiupcmd cluster display ${cluster_name} -R pd
else
   echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") pd leader 切换失败!"
fi
echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") script execute complete!"

exit 0
fi




#############################################################################################
if [ "$1" = "tikv_leader_evict" -o "$1" = "tle" ]; then
echo -e "${RED}*********************************** Need to execute under the tidb user and on tiup host! *********************************** ${RESET}"
read -p "input the tidb cluster name:" cluster_name
DT=`date +%Y%m%d%H%M%S`
echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") " 
$tiupcmd cluster display ${cluster_name} -R tikv
read -p "请输入需要驱逐kv leader的ip,例如192.10.2.201,192.168.2.202:20160: " kv_ip_list
echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") 需要驱逐kv leader的ip:${kv_ip_list}" 
IFS="," read -ra array <<< "$kv_ip_list"
#array=${kv_ip_list//,/}
> /tmp/${cluster_name}_ip_list_${DT}
pd_addr=`$tiupcmd cluster display ${cluster_name} -R pd |grep Up|awk  '{print $1}' |tail -1`
cluster_version=`$tiupcmd cluster display ${cluster_name} |grep "Cluster version:"|awk -F ":" '{print $2}'`
version=$(echo $cluster_version | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
for ip_addr in "${array[@]}"
do
   $DBUSER -N -e "SELECT store_id FROM information_schema.tikv_store_status WHERE address like  '${ip_addr}%' ;">>/tmp/${cluster_name}_ip_list_${DT}
done
echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") 本次kv leader 驱逐涉及store id：" 
cat /tmp/${cluster_name}_ip_list_${DT}
> /tmp/${cluster_name}_evict-leader_${DT}.sh
cat /tmp/${cluster_name}_ip_list_${DT}|while read line
do
   echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") IP:${line}"
   echo "$tiupcmd ctl:"${version}" pd -u "${pd_addr}" scheduler add evict-leader-scheduler  "${line}>> /tmp/${cluster_name}_evict-leader_${DT}.sh 
done
command_count=`cat /tmp/${cluster_name}_evict-leader_${DT}.sh|wc -l`
results_count=0
if [ -e  /tmp/${cluster_name}_evict-leader_${DT}.sh ]; then
    cat /tmp/${cluster_name}_evict-leader_${DT}.sh 
    sh  /tmp/${cluster_name}_evict-leader_${DT}.sh > /tmp/${cluster_name}_evict-leader_results_${DT}
    results_count=`cat /tmp/${cluster_name}_evict-leader_results_${DT}|grep Success|wc -l`
         if [  "$command_count" -ne "$results_count" ]; then
		echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") kv leader逐执行失败!" 
                exit 1
         fi
fi 
echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") kv leader 驱逐执行成功！" 
echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") 等待1分钟.." 
sleep 60
> /tmp/${cluster_name}_store_id_${DT}
cat /tmp/${cluster_name}_ip_list_${DT}|while read line
do
   echo "'"$line"',">> /tmp/${cluster_name}_store_id_${DT}
done
cat /tmp/${cluster_name}_store_id_${DT} 
store_results=`cat /tmp/${cluster_name}_store_id_${DT}`
store_ids=${store_results%?}
$DBUSER -N -e "SELECT store_id,is_leader,count(*) FROM information_schema.tikv_region_peers a  WHERE store_id in (${store_ids}) group by store_id,is_leader order by 1,2,3 ;" 
echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") script execute complete!" 

exit 0
fi


#############################################################################################
if [ "$1" = "tikv_leader_evict_recovery" -o "$1" = "tler" ]; then
echo -e "${RED}*********************************** Need to execute under the tidb user and on tiup host! *********************************** ${RESET}"
read -p "input the tidb cluster name:" cluster_name
DT=`date +%Y%m%d%H%M%S`
echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") " 
read -p "是否解除kv leader 驱逐(yes or no): " choise
echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") 是否解除kv leader 驱逐:${choise}" 
if [ "$choise" = "yes" ] ; then
    pd_addr=`$tiupcmd cluster display ${cluster_name} -R pd |grep Up|awk  '{print $1}' |tail -1`
    cluster_version=`$tiupcmd cluster display ${cluster_name} |grep "Cluster version:"|awk -F ":" '{print $2}'`
    version=$(echo $cluster_version | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
    echo "$tiupcmd ctl:"${version}" pd -u "${pd_addr}" scheduler remove evict-leader-scheduler"  > /tmp/remove_${cluster_name}_evict-leader_${DT}.sh
    echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") 驱逐脚本内容:" 
    cat /tmp/remove_${cluster_name}_evict-leader_${DT}.sh
    sh /tmp/remove_${cluster_name}_evict-leader_${DT}.sh > /tmp/remove_${cluster_name}_evict-leader_results_${DT}
    result=`cat /tmp/remove_${cluster_name}_evict-leader_results_${DT}|grep "Success"|wc -l`
    if [ "$result" = "1" ] ; then
        echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") 解除kv leader 驱逐成功！" 
        echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") 等待kv leader 重平衡..." 
        echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") 等待60秒" 
        sleep 60
        $DBUSER -N -e "SELECT store_id,count(*) FROM information_schema.tikv_region_peers a  WHERE is_leader=1 group by store_id order by 1 ;"
    else
        echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") 解除kv leader 驱逐失败！" 
    fi
fi

echo "$(date +"%Y-%m-%d %H:%M:%S.%3N") script execute complete!" 
exit 0
fi



#############################################################################################
if [ "$1" = "drcheck" -o "$1" = "dr" ]; then
echo -e "${RED}*********************************** Need to execute under the tidb user and on tiup host! *********************************** ${RESET}"
if [ "$2" = "" ]; then
   read -p "input the tidb cluster name:" cluster_name
else
   cluster_name=$2
fi

echo ""
echo "==================================== The PD Member Status ===================================="
$tiupcmd cluster display $cluster_name -R pd 2>/dev/null


echo ""
echo "==================================== The Region and Region Leader Distribute ===================================="
$DBUSER -e 2>/dev/null "SELECT address, 
       JSON_UNQUOTE(JSON_EXTRACT(label, '$\[2\]\.value')) AS dc,
       JSON_UNQUOTE(JSON_EXTRACT(label, '$\[0\]\.value')) AS logic,
       JSON_UNQUOTE(JSON_EXTRACT(label, '$\[1\]\.value')) AS host,
       leader_count,region_count,leader_weight,region_weight
FROM 
  information_schema.tikv_store_status
order by 2,3,4;"
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
$ECHO

echo ""
echo "==================================== The Placement-Rules Configuration ===================================="
pd_addr=`$tiupcmd cluster display ${cluster_name} -R pd |grep Up|awk  '{print $1}' |tail -1`
cluster_version=`$tiupcmd cluster display ${cluster_name} |grep "Cluster version:"|awk -F ":" '{print $2}'`
version=$(echo $cluster_version | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
$tiupcmd ctl:$version pd -u $pd_addr config placement-rules show 2>/dev/null |jq -r '.[] | "[\(.id)].[\(.role)].\(.label_constraints[].values)"'|sort 


echo ""
echo "==================================== The DR Auto-Sync Configuration ===================================="
pd_addr=`$tiupcmd cluster display ${cluster_name} -R pd |grep Up|awk  '{print $1}' |tail -1`
cluster_version=`$tiupcmd cluster display ${cluster_name} |grep "Cluster version:"|awk -F ":" '{print $2}'`
version=$(echo $cluster_version | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
$tiupcmd ctl:$version pd -u $pd_addr config show replication-mode 2>/dev/null

exit 0
fi






#############################################################################################
if [ "$1" = "user" ]; then

    $DBUSER -e 2>/dev/null "
    select  
        Host                     ,
        User                     ,
        plugin                   ,
        password_expired         ,
        password_last_changed    ,
        password_lifetime        ,
        account_locked                
        from mysql.user;
    ";
    if [ "$?" -gt "0" ]; then
       echo "Execution Failed!"
    fi
    $ECHO

exit 0
fi



